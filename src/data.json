[
    {
      "titleBlock": "Number()",
      "properties": [
        {
          "name": ".POSITIVE_INFINITY",
          "class": "number",
          "description": ".POSITIVE_INFINITY - це спеціальне число, яке означає \"нескінченність\" у JavaScript.\n                 Це значення використовується, коли потрібно визначити, що деяке число є дуже великим або бескінечним.",
          "code": "\n // Приклад використання .POSITIVE_INFINITY для визначення найбільшого значення в масиві\nconst numbers = [5, 10, 15, 20, 25];\nlet max = Number.NEGATIVE_INFINITY;\nfor (const number of numbers) {\n    if (number > max) {\n        max = number;\n    }\n}\nconsole.log(max); // 25\n                \n// Приклад використання .POSITIVE_INFINITY при обчисленні математичної формули\nconst a = 5;\nconst b = 10;\nconst result = a / (a - b);\nif (result === Number.POSITIVE_INFINITY) {\n  console.log(\"Результат не може бути вирахований\");\n} else {\n  console.log(result);\n}\n\n\n",
          "type": "Number()"
        },
        {
          "name": ".NEGATIVE_INFINITY",
          "class": "number",
          "description": ".NEGATIVE_INFINITY це спеціальне значення в JavaScript, яке представляє від'ємну нескінченність. \n                Воно використовується для представлення значення, яке менше за будь-яке інше можливе число.",
          "code": "\n//Приклад 1:\nif (x > 0) {\n    x = Number.NEGATIVE_INFINITY;\n  } \n\n//Приклад 2:\nfunction minValue(arr) {\n    let min = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] < min) {\n        min = arr[i];\n      }\n    }\n    return min;\n  }\n                \n                ",
          "type": "Number()"
        },
        {
          "name": ".MAX_VALUE",
          "class": "number",
          "description": ".MAX_VALUE це спеціальне значення в JavaScript, яке представляє максимальне значення числа, яке може бути вираховане в JavaScript.",
          "code": "\n//Приклад 1:\nif (x > Number.MAX_VALUE) {\n    x = Number.MAX_VALUE;\n  }  \n\n//Приклад 2:\nfunction maxValue(arr) {\n    let max = Number.MIN_VALUE;\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] > max) {\n        max = arr[i];\n      }\n    }\n    return max;\n  } \n         ",
          "type": "Number()"
        },
        {
          "name": ".MIN_VALUE",
          "class": "number",
          "description": ".MIN_VALUE це спеціальне значення в JavaScript, яке представляє найменше значення числа, яке може бути вираховане в JavaScript.",
          "code": "\n//Приклад 1:\nif (x < Number.MIN_VALUE) {\n    x = Number.MIN_VALUE;\n  }\n\n//Приклад 2:\nfunction minValue(arr) {\n    let min = Number.MAX_VALUE;\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i] < min) {\n        min = arr[i];\n      }\n    }\n    return min;\n  }\n        ",
          "type": "Number()"
        },
        {
          "name": ".EPSILON",
          "class": "number",
          "description": ".EPSILON це спеціальне значення в JavaScript, яке представляє мінімальну крокову величину, відмінну від нуля, яку може вирахувати JavaScript. Це значення може використовуватися для перевірки на рівність двох дробових чисел.",
          "code": "\n// Приклад 1:\nfunction areEqual(a, b) {\n    return Math.abs(a - b) < Number.EPSILON;\n  }\n\n//Приклад 2:\nfunction withinEpsilon(a, b, epsilon = Number.EPSILON) {\n    return Math.abs(a - b) < epsilon;\n  }\n  \n                ",
          "type": "Number()"
        },
        {
          "name": ".NaN",
          "class": "nan",
          "description": ".NaN є спеціальним значенням в JavaScript, яке означає \"не число\". Це значення використовується, коли операція не може бути виконана і в результаті видається значення, яке не є числом.",
          "code": "\n//Приклад 1:\nlet result = Math.sqrt(-1);\nconsole.log(result); // NaN\n\n//Приклад 2:\nlet str = \"not a number\";\nlet result = parseInt(str);\nconsole.log(result); // NaN\n\n                ",
          "type": "Number()"
        }
      ],
      "methods": {
        "basicMethods": [
          {
            "name": ".toExponential()",
            "class": "string",
            "description": "Метод .toExponential() в JavaScript використовується для перетворення числового значення в формат експоненціального представлення.",
            "code": "\n// Приклад 1:\nlet num = 123456789;\nlet result = num.toExponential();\nconsole.log(result); // \"1.23456789e+8\"\n\n// Приклад 2:\nlet num = 0.0000123;\nlet result = num.toExponential(2);\nconsole.log(result); // \"1.23e-5\"\n\n",
            "type": "Number()"
          },
          {
            "name": ".toFixed()",
            "class": "string",
            "description": "Метод .toFixed() в JavaScript використовується для обробки числового значення та отримання результату як рядка з заданою кількістю знаків після коми.",
            "notice": "fixed-point notation",
            "code": "\n//Приклад 1:\nlet num = 123.456;\nlet result = num.toFixed(1);\nconsole.log(result); // \"123.5\"\n\n//Приклад 2:\nlet num = 123.456789;\nlet result = num.toFixed(4);\nconsole.log(result); // \"123.4568\"\n\n                    ",
            "type": "Number()"
          },
          {
            "name": ".toPrecision()",
            "class": "string",
            "description": "toPrecision() - це метод JavaScript, який використовується для форматування дійсного числа в рядок, який містить задану кількість цифр після десяткової коми.",
            "notice": "change precision",
            "code": "\n//Приклади використання:\nlet num = 123456.789;\nlet precision = 4;\nlet result = num.toPrecision(precision);\nconsole.log(result); // \"123456.8\"\n\n\nlet num = 0.0000000123;\nlet precision = 2;\nlet result = num.toPrecision(precision);\nconsole.log(result); // \"1.2e-8\"\n\n                    ",
            "type": "Number()"
          },
          {
            "name": ".isFinite()",
            "class": "boolean",
            "description": "isFinite() є функцією в JavaScript, яка перевіряє, чи є значення конечним числом. Вона повертає true, якщо значення є конечним числом, тобто не є бескінечністю або NaN.",
            "notice": "",
            "code": "\n// Два приклади використання:\n\nconsole.log(isFinite(123)); // true\nconsole.log(isFinite(1/0)); // false\n\n                    ",
            "type": "Number()"
          },
          {
            "name": ".isInteger()",
            "class": "boolean",
            "description": ".isInteger() - це метод JavaScript, який перевіряє, чи є задане значення цілим числом. Він повертає значення true у випадку, коли задане значення є цілим числом, інакше повертає значення false.",
            "notice": "",
            "code": "\n// Приклади використання:\n\n// Перевірка числа на цілість:\nconsole.log(Number.isInteger(4)); // true\nconsole.log(Number.isInteger(4.5)); // false\n\n// Використання в умовному операторі:\nlet num = 5.5;\nif (!Number.isInteger(num)) {\n  console.log(\" num  is not an integer\"); // 5.5 is not an integer\n}\n                    ",
            "type": "Number()"
          },
          {
            "name": ".isNaN()",
            "class": "boolean",
            "description": "isNaN() - це функція JavaScript, яка перевіряє, чи являється вхідне значення \"Not-a-Number\" (NaN). Функція повертає true, якщо значення є NaN, і false в іншому випадку.",
            "notice": "",
            "code": "\n// Визначення неправильного типу даних в виразі:\nlet x = \"abc\";\nif (isNaN(x)) {\n  console.log(\"Not a number\");\n} else {\n  console.log(\"Is a number\");\n}\n\n// Визначення NaN в результаті арифметичної операції:\nlet y = Math.sqrt(-1);\nif (isNaN(y)) {\n  console.log(\"Result is NaN\");\n} else {\n  console.log(\"Result is a number\");\n}\n\n                    ",
            "type": "Number()"
          },
          {
            "name": ".parseInt()",
            "class": "number",
            "description": ".parseInt() - це функція JavaScript, яка перетворює рядок в ціле число.",
            "notice": "",
            "code": "\n// Приклади використання:\n\n// Перетворення рядка з відповідною цілою величиною:\nlet numberString = \"23\";\nlet number = parseInt(numberString);\nconsole.log(number); // 23\n\n// Використання функції із системою счислення:\nlet binary = \"1010\";\nlet decimal = parseInt(binary, 2);\nconsole.log(decimal); // 10\n\n                    ",
            "type": "Number()"
          },
          {
            "name": ".parseFloat()",
            "class": "number",
            "description": "parseFloat() - це встановлений метод JavaScript, який перетворює рядок (або інший тип даних) в дійсне число типу float.",
            "notice": "",
            "code": "\n//Приклади використання:\n\n//Перетворення рядку в дійсне число:\nlet num = \"3.14159265\";\nlet floatNum = parseFloat(num);\nconsole.log(floatNum); // 3.14159265\n\n// Використання з відфільтровуванням недопустимих значень:\nlet string = \"not a number\";\nlet floatNum = parseFloat(string);\nif (!isNaN(floatNum)) {\n   console.log(floatNum);\n} else {\n   console.log(\"Invalid input\");\n}\n// Output: Invalid input\n                    ",
            "type": "Number()"
          }
        ],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "String()",
      "properties": [
        {
          "name": ".length",
          "class": "number",
          "notice": "довжина рядка",
          "description": "\"string.length\" є спеціальною властивістю рядків в JavaScript, яка повертає довжину рядка.",
          "code": "\n// Приклади:\n\n// Визначити довжину рядка:\nlet str = \"Hello, World!\";\nlet length = str.length;\nconsole.log(length);  // 13\n\n// Перевірити чи рядок містить відповідну кількість символів:\nlet password = \"password123\";\nif (password.length >= 8) {\n  console.log(\"Password is strong enough.\");\n} else {\n  console.log(\"Password is too short.\");\n}\n\n\n                ",
          "type": "String()"
        }
      ],
      "methods": {
        "basicMethods": [
          {
            "name": ".charAt(index)",
            "class": "string",
            "notice": "",
            "description": ".charAt(index) - це метод, який повертає символ, розташований на вказаній позиції (index) в рядку.",
            "code": "\n// Приклади використання:\nlet str = 'Hello, world!';\nconsole.log(str.charAt(0)); // 'H'\n\nlet name = 'John';\nconsole.log(name.charAt(3)); // 'n'\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".charCodeAt(index)",
            "class": "number",
            "notice": "",
            "description": "\"charCodeAt\" - це метод рядків (string) у JavaScript, який повертає Unicode-кодову позицію символу в рядку за вказаним індексом.",
            "code": "\n// Приклади використання:\n\n// Визначення коду символу \"H\" в рядку \"Hello, World!\":\nlet str = \"Hello, World!\";\nlet charCode = str.charCodeAt(0);\nconsole.log(charCode);\n\n// Перетворення рядку в масив кодів символів:\nlet str = \"Hello, World!\";\nlet charCodes = [];\nfor (let i = 0; i < str.length; i++) {\n  charCodes.push(str.charCodeAt(i));\n}\nconsole.log(charCodes);\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".codePointAt(index)",
            "class": "number",
            "notice": "",
            "description": ".codePointAt(index) - це метод JavaScript, який повертає цілочисельне значення UTF-16 для символа в рядку на вказаному індексі.",
            "code": "\n// Приклади використання:\nconst message = 'Hello, World!';\nconsole.log(message.codePointAt(0)); // 72\n\nconst emoji = '🌟';\nconsole.log(emoji.codePointAt(0)); // 127775\n\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".fromCharCode(n1, n2...)",
            "class": "string",
            "notice": "",
            "description": ".fromCharCode(n1, n2, ...) - це статичний метод JavaScript, який повертає рядок, створений з відповідних символів UTF-16, відображаних цілочисельними кодами.",
            "code": "\n// Приклади використання:\nconsole.log(String.fromCharCode(72, 101, 108, 108, 111)); // \"Hello\"\n\nconst starCode = 127775;\nconsole.log(String.fromCharCode(starCode)); // \"🌟\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".fromCodePoint(n1, n2...)",
            "class": "string",
            "notice": "",
            "description": ".fromCodePoint(n1, n2, ...) - це статичний метод JavaScript, який повертає рядок, створений з відповідних символів Unicode, відображаних цілочисельними кодами.",
            "code": "\n// Приклади використання:\nconsole.log(String.fromCodePoint(72, 101, 108, 108, 111)); // \"Hello\"\n\nconst starCode = 0x1F31F;\nconsole.log(String.fromCodePoint(starCode)); // \"🌟\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".concat(str1, str2...)",
            "class": "string",
            "notice": "",
            "description": ".concat(str1, str2, ...) - це метод JavaScript, який додає один або більше рядків до кінця поточного рядка і повертає новий рядок.",
            "code": "\n// Приклади використання:\nconst message = 'Hello';\nconsole.log(message.concat(',', ' World!')); // \"Hello, World!\"\n\nconst firstName = 'John';\nconst lastName = 'Doe';\nconsole.log(firstName.concat(' ', lastName)); // \"John Doe\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".startsWith(str, size) ",
            "class": "boolean",
            "notice": "",
            "description": ".startsWith(str, size) - це метод JavaScript, який визначає, чи починається поточний рядок з вказаного підрядка. Параметр size визначає початок порівняння в поточному рядку.",
            "code": "\n// Приклади використання:\nconst message = 'Hello World';\nconsole.log(message.startsWith('Hello')); // true\n\nconst fileName = 'image.png';\nconsole.log(fileName.startsWith('.png', fileName.length - 4)); // true\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".endsWith(str, size)",
            "class": "boolean",
            "notice": "",
            "description": ".endsWith(str, size) - це метод JavaScript, який визначає, чи закінчується поточний рядок вказаним підрядком. Параметр size визначає кінець порівняння в поточному рядку.",
            "code": "\n// Приклади використання:\nconst message = 'Hello World';\nconsole.log(message.endsWith('World')); // true\n\nconst fileName = 'image.png';\nconsole.log(fileName.endsWith('.png')); // true\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".includes(str, from)",
            "class": "boolean",
            "notice": "",
            "description": ".includes() - це метод строк в JavaScript, який використовується для визначення чи строка містить якусь відому підстроку. Метод приймає два аргументи: строку, яку ми шукаємо (str), та початок пошуку (from), якщо він вказаний.",
            "code": "\n// Приклади використання:\nconst str1 = \"Hello World\";\nconsole.log(str1.includes(\"Hello\")); // true\nconsole.log(str1.includes(\"Hi\")); // false\n\nconst str2 = \"Welcome to the jungle\";\nconsole.log(str2.includes(\"to\", 10)); // true\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".indexOf(str, from)",
            "class": "number",
            "notice": "",
            "description": ".indexOf() - це метод строк в JavaScript, який використовується для визначення індексу першого входження відомої підстроки в строку. Метод приймає два аргументи: строку, яку ми шукаємо (str), та початок пошуку (from), якщо він вказаний. Якщо підстрока не знайдена, метод поверне -1.",
            "code": "\n// Приклади використання:\nconst str1 = \"Hello World\";\nconsole.log(str1.indexOf(\"Hello\")); // 0\nconsole.log(str1.indexOf(\"Hi\")); // -1\n\nconst str2 = \"Welcome to the jungle\";\nconsole.log(str2.indexOf(\"to\", 10)); // 13\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".lastIndexOf(str, from)",
            "class": "number",
            "notice": "",
            "description": ".lastIndexOf() - це метод строк в JavaScript, який використовується для визначення індексу останнього входження відомої підстроки в строку. Метод приймає два аргументи: строку, яку ми шукаємо (str), та початок пошуку (from), якщо він вказаний. Якщо підстрока не знайдена, метод поверне -1.",
            "code": "\n// Приклади використання:\nconst str1 = \"Hello World\";\nconsole.log(str1.lastIndexOf(\"l\")); // 9\nconsole.log(str1.lastIndexOf(\"z\")); // -1\n\nconst str2 = \"Welcome to the jungle\";\nconsole.log(str2.lastIndexOf(\"o\", 15)); // 7\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".search(regex)",
            "class": "number",
            "notice": "",
            "description": ".search() - це метод строк в JavaScript, який використовується для пошуку відповідності регулярного виразу в строкі. Метод приймає один аргумент: регулярний вираз (regex), який ми шукаємо. Якщо відповідність знайдена, метод повертає індекс першої відповідності. Якщо відповідність не знайдена, метод повертає -1.",
            "code": "\n// Приклади використання:\nconst str1 = \"Hello World\";\nconsole.log(str1.search(/l/i)); // 2\nconsole.log(str1.search(/z/i)); // -1\n\nconst str2 = \"1234567890\";\nconsole.log(str2.search(/ d{3}/)); // 0\nconsole.log(str2.search(/ d{11}/)); // -1\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".localeCompare(str, locale, options)",
            "class": "number",
            "notice": "",
            "description": ".localeCompare() - це метод строк в JavaScript, який використовується для порівняння двох строк в залежності від вказаного локального налаштування. Метод приймає три аргументи: строку для порівняння (str), локальне налаштування (locale), яке може бути вказане як рядок, та опції (options), які можуть визначати спосіб сортування. Метод повертає значення 0, якщо строки рівні, -1 якщо перша строка менша за другу, та 1 якщо перша строка більша за другу.",
            "code": "\n// Приклади використання:\nconst str1 = \"a\";\nconst str2 = \"b\";\nconsole.log(str1.localeCompare(str2)); // -1\nconsole.log(str2.localeCompare(str1)); // 1\nconsole.log(str1.localeCompare(str1)); // 0\n\nconst str3 = \"ä\";\nconst str4 = \"z\";\nconsole.log(str3.localeCompare(str4, \"de\")); // -1\nconsole.log(str4.localeCompare(str3, \"de\")); // 1\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".match(regex)",
            "class": "array",
            "notice": "",
            "description": ".match(regex) - це метод JavaScript, який використовується для пошуку відповідностей межу в даному рядку тексту. Він повертає масив зі всіма відповідностями, які знайдені в рядку.",
            "code": "\n// Приклади:\n\n// Пошук всіх чисел в рядку:\nlet str = \"Це рядок з числами 123 и 456\";\nlet regex = /d+/g;\nlet matches = str.match(regex);\nconsole.log(matches); // [\"123\", \"456\"]\n\n// Пошук всіх слів, що починаються з великої літери:\nlet str = \"Це рядок з великими літерами в словах\";\nlet regex = /\b[A-Z][a-z]+\b/g;\nlet matches = str.match(regex);\nconsole.log(matches); // [\"Це\", \"Великими\", \"Літерами\", \"Словах\"]\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".matchAll(regex)",
            "class": "array",
            "notice": "",
            "description": "String.prototype.matchAll(regex) - це метод JavaScript, який використовується для знаходження всіх відповідностей для регулярного виразу в рядку. Він повертає генератор з відповідностей.",
            "code": "\n// Приклади використання:\nlet string = \"Hello World\";\nlet regex = /w+/g;\nlet matches = [...string.matchAll(regex)];\nconsole.log(matches);\n// Output: [Array(2), Array(2), Array(2), Array(2), Array(2)]\n\n\nlet string = \"I love JavaScript\";\nlet regex = /\b(w+)\b/g;\nlet matches = [...string.matchAll(regex)];\nconsole.log(matches);\n// Output: [Array(2), Array(2), Array(2), Array(2)]\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".normalize(form)",
            "class": "string",
            "notice": "",
            "description": ".normalize(form) - Це метод JavaScript, який нормалізує рядок Unicode в визначену форму нормалізації.\n                    form - Обов'язковий параметр, який визначає форму нормалізації. Може бути \"NFC\", \"NFD\", \"NFKC\" або \"NFKD\".",
            "code": "\n// Приклади використання:\n\n// Нормалізація рядка для універсальної компараторної операції:\nlet str = \"ćafé\";\nconsole.log(str.normalize(\"NFC\")); // \"ćafé\"\n\n// Використання для порівняння рядків:\nlet str1 = \"résumé\";\nlet str2 = \"résumé\";\nconsole.log(str1.normalize(\"NFC\") === str2); // true\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".padEnd(len, pad)",
            "class": "string",
            "notice": "",
            "description": ".padEnd(len, pad) - це метод JavaScript, який додає символи до кінця рядка, доки його довжина не буде рівна вказаній довжині. Якщо рядок вже має вказану довжину, він не змінюється.",
            "code": "\n// Приклади використання:\n\n// Додати пробіли до кінця рядка, щоб довжина стала 10 символів:\nlet str = 'hello';\nstr = str.padEnd(10, ' ');\nconsole.log(str);  // \"hello     \"\n\n// Додати символи \"#\" до кінця рядка, щоб довжина стала 15 символів:\nlet str = 'javascript';\nstr = str.padEnd(15, '#');\nconsole.log(str);  // \"javascript#####\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".padStart(len, pad)",
            "class": "string",
            "notice": "",
            "description": ".padStart(len, pad) - це метод JavaScript, який додає додатковий рядок (pad) до початку рядка, доки довжина рядка не стане рівною len.",
            "code": "\n// Приклади використання:\n\n// Додати нулі до початку числа:\nlet num = 123; \nlet padded = num.toString().padStart(5, '0'); \nconsole.log(padded); // \"00123\"\n\n// Додати пробіли до початку імені:\nlet name = \"John\"; \nlet padded = name.padStart(10, ' '); \nconsole.log(padded); // \"     John\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".repeat(n)",
            "class": "string",
            "notice": "",
            "description": ".repeat(n) - Метод повторює рядок n разів.",
            "code": "\n// Приклади:\n\n// Створення повторюваної пробільної стрічки:\nlet space = ' '.repeat(5);\nconsole.log(space); // \"     \"\n\n// Виведення повторюваної написаної фрази:\nlet message = 'Hello!'.repeat(3);\nconsole.log(message); // \"Hello!Hello!Hello!\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".replace(str|regex, newstr|func)",
            "class": "string",
            "notice": "",
            "description": "\"replace()\" є методом строк в JavaScript, який використовується для заміни тексту в строці. Ви можете використовувати строку або регулярний вираз в якості аргументу \"str|regex\", а заміну можете встановити в якості строки або функції.",
            "code": "\n// Приклади:\n\n// Замінити всі входження слова \"javascript\" на слово \"JS\"\nlet str = \"I love javascript\";\nstr = str.replace(\"javascript\", \"JS\");\nconsole.log(str);  // \"I love JS\"\n\n// Замінити всі входження цифр в строці на відповідні букви\nlet str = \"There are 5 dogs\";\nstr = str.replace(/d/g, function(match) {\n  switch (match) {\n    case '0': return 'zero';\n    case '1': return 'one';\n    case '2': return 'two';\n    case '3': return 'three';\n    case '4': return 'four';\n    case '5': return 'five';\n    case '6': return 'six';\n    case '7': return 'seven';\n    case '8': return 'eight';\n    case '9': return 'nine';\n  }\n});\nconsole.log(str);  // \"There are five dogs\"\n\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".slice(ini, end)",
            "class": "string",
            "notice": "",
            "description": ".slice(ini, end) є методом JavaScript, який використовується для вирізання частини рядка від позиції \"ini\" до позиції \"end\". Якщо позиція \"end\" не вказана, то метод відрізає рядок від позиції \"ini\" до кінця рядка.",
            "code": "\n// Приклади використання:\n\n// Вирізати першу половину рядка:\nconst str = \"Hello World!\";\nconst result = str.slice(0, 5);\nconsole.log(result); // Output: \"Hello\"\n\n// Вирізати останній символ рядка:\nconst str = \"Hello World!\";\nconst result = str.slice(-1);\nconsole.log(result); // Output: \"!\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".substr(ini, len)",
            "class": "string",
            "notice": "",
            "description": ".substr(ini, len) - це метод рядку JavaScript, який вирізає підрядок з початкової позиції \"ini\" довжиною \"len\".",
            "code": "\n// Приклад використання:\n\nconst str = \"Hello World\";\nconst substr = str.substr(0, 5);\nconsole.log(substr); // Output: \"Hello\"\n\n\nconst str = \"Javascript\";\nconst substr = str.substr(3, 8);\nconsole.log(substr); // Output: \"ascript\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".substring(ini, end)",
            "class": "string",
            "notice": "",
            "description": ".substring(ini, end) - це метод строки в JavaScript, який використовується для вибірки частини строки заданого діапазону.",
            "code": "\n// Приклад 1:\nlet str = 'Hello World';\nlet result = str.substring(0, 5);\nconsole.log(result); // \"Hello\"\n\n// Приклад 2:\nlet str = 'Hello World';\nlet result = str.substring(7);\nconsole.log(result); // \"World\"\n\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".split(sep|regex, limit)",
            "class": "array",
            "notice": "",
            "description": ".split() - це метод рядка JavaScript, який дозволяє розділяти рядок на масив строк, використовуючи роздільник або регулярний вираз.\n\n                    Параметри:\n                    \n                        sep|regex - рядок або регулярний вираз, який використовується як роздільник\n                        limit - обмеження кількості результуючих частин",
            "code": "\n// Приклади використання:\n\n// Розділити рядок на масив слів, використовуючи пробіл як роздільник:\nconst sentence = \"Hello world\"; \nconst words = sentence.split(\" \"); \nconsole.log(words); // [ \"Hello\", \"world\" ]\n\n// Розділити рядок на масив чисел, використовуючи кому як роздільник:\nconst numbers = \"1,2,3,4,5\"; \nconst numArray = numbers.split(\",\"); \nconsole.log(numArray); // [ \"1\", \"2\", \"3\", \"4\", \"5\" ]\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".toLowerCase()",
            "class": "string",
            "notice": "",
            "description": ".toLowerCase() - це метод строки, який повертає копію строки з всіма буквами в нижньому регістрі.",
            "code": "\n// Приклади використання:\n\nlet greeting = \"HELLO WORLD\";\nlet lowerCaseGreeting = greeting.toLowerCase();\nconsole.log(lowerCaseGreeting);\nВиведе: hello world\n\nlet userInput = \"MiXeD CaSe InpUt\";\nlet processedInput = userInput.toLowerCase();\nconsole.log(processedInput);\nВиведе: mixed case input\n                    ",
            "type": "String()"
          },
          {
            "name": ".toUpperCase()",
            "class": "string",
            "notice": "",
            "description": ".toUpperCase() - це метод JavaScript для рядків, який конвертує всі літери рядка в верхній регістр.",
            "code": "\n// Приклади використання:\n\n// Конвертування рядка в верхній регістр:\nlet name = \"john doe\";\nlet upperCaseName = name.toUpperCase();\nconsole.log(upperCaseName); // \"JOHN DOE\"\n\n\n// Перевірка регістру літер у рядку:\nlet password = \"secret\";\nlet input = \"SECRET\";\n\nif (input.toUpperCase() === password.toUpperCase()) {\n    console.log(\"Password is correct.\");\n} else {\n    console.log(\"Password is incorrect.\");\n}\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".trim()",
            "class": "string",
            "notice": "",
            "description": "trim() - це метод, який видаляє початкові та кінцеві пропуски в рядку.",
            "code": "\n// Приклади використання:\n\n// Перед перевіркою валідності введеного користувачем значення:\nlet userInput = \"  some text with spaces  \";\nuserInput = userInput.trim();\n\n// Перед порівнянням рядків, видаляючи всі пропуски на початку та в кінці рядка:\nlet firstString = \"  first string with spaces  \";\nlet secondString = \"second string with spaces\";\nif (firstString.trim() === secondString.trim()) {\n  console.log(\"Strings are equal\");\n}\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".trimEnd()",
            "class": "string",
            "notice": "",
            "description": "trimEnd() - це метод рядків в JavaScript, який видаляє всі пробільні символи з кінця рядка.",
            "code": "\n// Приклади використання:\nlet str = \"   Hello World!   \";\nconsole.log(str.trimEnd());\n// Output: \"   Hello World!\"\n\n\nlet str = \"JavaScript   \";\nconsole.log(str.trimEnd());\n// Output: \"JavaScript\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".trimStart()",
            "class": "string",
            "notice": "",
            "description": ".trimStart() це метод строки в JavaScript, який видаляє пробіли в початку строки.",
            "code": "\n// Приклади використання:\nlet str = \"   Hello World!\";\nconsole.log(str.trimStart()); // Output: \"Hello World!\"\n\n\nlet str = \"\t\t\t Welcome to the world of JavaScript\";\nconsole.log(str.trimStart()); // Output: \"Welcome to the world of JavaScript\"\n\n                    ",
            "type": "String()"
          },
          {
            "name": ".raw``",
            "class": "string",
            "notice": "",
            "description": ".raw - це шаблонний літерал в JavaScript, який відображає зовнішній вигляд шаблонної строки без виконання власної втілення і заміни перемінних.",
            "code": "",
            "type": "String()"
          }
        ],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "Array()",
      "properties": [
        {
          "name": ".length",
          "class": "number",
          "notice": "кількість елементів",
          "description": "Array.length - це властивітсь массиву, яка відображає кількість елементів в массиві. Це може використовуватися для визначення довжини массиву.",
          "code": "\n// Приклади використання:\n\n// Визначення довжини массиву:\nlet fruits = ['apple', 'banana', 'mango'];\nconsole.log(fruits.length); // 3\n\n// Використання в циклі для перебору всіх елементів массиву:\nlet numbers = [1, 2, 3, 4, 5];\nfor (let i = 0; i < numbers.length; i++) {\n    console.log(numbers[i]);\n}\n                ",
          "type": "Array()"
        }
      ],
      "methods": {
        "basicMethods": [
          {
            "name": ".isArray()",
            "class": "boolean",
            "notice": "",
            "description": ".isArray() - це метод JavaScript, який використовується для визначення, чи є обєкт масивом. Він повертає значення true, якщо об'єкт є масивом, і false, якщо він не є масивом.",
            "code": "\n// Приклади використання: \n\n// Визначення, чи є обєкт масивом:\nlet fruits = ['apple', 'banana', 'cherry'];\nconsole.log(Array.isArray(fruits)); // true\n\nlet notArray = 'apple';\nconsole.log(Array.isArray(notArray)); // false\n\n// Використання в умовному операторі:\nlet value = 'apple';\n\nif (Array.isArray(value)) {\n  console.log('value is an array');\n} else {\n  console.log('value is not an array');\n}\n\n                    ",
            "type": "Array()"
          },
          {
            "name": ".includes()",
            "class": "boolean",
            "notice": "",
            "description": "Array.includes() - це метод JavaScript, який використовується для перевірки чи міститься елемент у масиві. Він повертає значення true або false в залежності від того, чи міститься елемент у масиві або ні",
            "code": "\n// Приклад 1:\nlet arr = [1, 2, 3, 4];\n\nconsole.log(arr.includes(2)); // true\nconsole.log(arr.includes(5)); // false\n\n// Приклад 2:\nlet arr = ['apple', 'banana', 'cherry'];\n\nconsole.log(arr.includes('apple')); // true\nconsole.log(arr.includes('pear')); // false\n\n                    \n                    ",
            "type": "Array()"
          },
          {
            "name": ".indexOf()",
            "class": "number",
            "notice": "",
            "description": ".indexOf() - це метод JavaScript, який використовується для пошуку індексу першого входження заданого елементу в масиві. Якщо елемент не знайдено, то метод поверне -1.",
            "code": "\n// Приклади використання:\n\n// Визначення індексу певного елементу в масиві:\nlet fruits = ['apple', 'banana', 'mango'];\nlet index = fruits.indexOf('banana');\nconsole.log(index); // 1\n\n// Використання для перевірки наявності елементу в масиві:\nlet fruits = ['apple', 'banana', 'mango'];\nlet exists = fruits.indexOf('orange') !== -1;\nconsole.log(exists); // false\n\n                    ",
            "type": "Array()"
          },
          {
            "name": ".lastIndexOf()",
            "class": "number",
            "notice": "",
            "description": ".lastIndexOf() є методом масиву JavaScript, який використовується для пошуку індексу останнього входження вказаного значення в масив. Якщо значення не знайдено, метод поверне -1.",
            "code": "\n// Приклади використання:\n\n// Пошук останнього індексу входження вказаного значення:\nconst array = [2, 5, 9, 2];\nconst lastIndex = array.lastIndexOf(2);\nconsole.log(lastIndex); // 3\n\n// Визначення існування значення в масиві:\nconst array = [2, 5, 9, 2];\nconst isValueExists = array.lastIndexOf(7) !== -1;\nconsole.log(isValueExists); // false\n\n                    ",
            "type": "Array()"
          },
          {
            "name": ".join(sep)",
            "class": "string",
            "notice": "",
            "description": ".join() - це метод масиву в JavaScript, який дозволяє трансформувати масив в рядок використовуючи вказаний роздільник.",
            "code": "\n// Приклади використання:\n\n// Перетворення масиву на рядок розділених комами:\nconst colors = ['red', 'green', 'blue'];\nconsole.log(colors.join(', '));\n// Output: 'red, green, blue'\n\n// Об'єднання елементів масиву в один рядок:\nconst elements = ['Hydrogen', 'Helium', 'Lithium'];\nconst result = elements.join('');\nconsole.log(result);\n// Output: 'HydrogenHeliumLithium'\n\n                    ",
            "type": "Array()"
          },
          {
            "name": ".slice()",
            "class": "array",
            "notice": "",
            "description": ".slice() - це метод масиву в JavaScript, який використовується для отримання нового масиву з підмасиву від відповідного початку до кінця (за замовчуванням до кінця масиву).",
            "code": "\n//  Приклади:\n\n// 1:\nlet fruits = ['apple', 'banana', 'kiwi', 'mango'];\nlet slicedFruits = fruits.slice(1, 3);\n\nconsole.log(slicedFruits); // Output: [ 'banana', 'kiwi' ]\n\n// 2:\nlet numbers = [1, 2, 3, 4, 5];\nlet slicedNumbers = numbers.slice(3);\n\nconsole.log(slicedNumbers); // Output: [ 4, 5 ]\n\n                    ",
            "type": "Array()"
          },
          {
            "name": ".concat()",
            "class": "array",
            "notice": "",
            "description": ".concat() є методом масиву в JavaScript, який дозволяє об'єднати два або більше масивів в один. Результуючий масив стає сумою всіх вхідних масивів, але первинні масиви не змінюються.",
            "code": "\n// Приклади використання:\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\nlet result = arr1.concat(arr2);\nconsole.log(result);  // [1, 2, 3, 4, 5, 6]\n\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\nlet arr3 = [7, 8, 9];\nlet result = arr1.concat(arr2, arr3);\nconsole.log(result);  // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n                    ",
            "type": "Array()"
          },
          {
            "name": ".flat()",
            "class": "array",
            "notice": "",
            "description": ".flat() - це метод JavaScript, який додає всі вкладені масиви в один плоский масив.",
            "code": "\n// Приклад 1:\nlet arr = [1, 2, [3, 4, [5, 6]]];\nconsole.log(arr.flat()); \n// output: [1, 2, 3, 4, 5, 6]\n\n// Приклад 2:\nlet arr = [1, 2, [3, 4, [5, 6, [7, 8]]]]];\nconsole.log(arr.flat(2)); \n// output: [1, 2, 3, 4, 5, 6, 7, 8]\n\n\n                    ",
            "type": "Array()"
          }
        ],
        "data1": {
          "data1title": "MODIFY SOURCE ARRAY METHODS",
          "data2": [
            {
              "name": ".copyWithin()",
              "class": "array",
              "notice": "",
              "description": ".copyWithin() - це метод масиву JavaScript, який копіює елементи всередину масиву від одного індексу до іншого індексу.",
              "code": "\n//Приклади:\n\n// Копіювання елементів від початку до кінця масиву:\nlet arr = [1, 2, 3, 4, 5];\narr.copyWithin(0, 2);\nconsole.log(arr);  // [3, 4, 5, 4, 5]\n\n// Копіювання елементів від кінця до початку масиву:\nlet arr = [1, 2, 3, 4, 5];\narr.copyWithin(0, 3, 4);\nconsole.log(arr);  // [4, 2, 3, 4, 5]\n\n                        ",
              "type": "Array()"
            },
            {
              "name": ".fill()",
              "class": "array",
              "notice": "",
              "description": "fill() це метод масиву, який заповнює всі елементи масиву заданим значенням. Воно може бути використане для ініціалізації масиву заданим значенням або для видалення існуючих значень.",
              "code": "\n// Приклади використання:\n\n// Ініціалізація масиву заданим значенням:\nlet array = new Array(5).fill(0);\nconsole.log(array); // [0, 0, 0, 0, 0]\n\n// Заміна елементів масиву заданим значенням:\nlet array = [1, 2, 3, 4, 5];\narray.fill('x', 2, 4);\nconsole.log(array); // [1, 2, 'x', 'x', 5]\n\n                        ",
              "type": "Array()"
            },
            {
              "name": ".reverse()",
              "class": "array",
              "notice": "",
              "description": "reverse() - це метод для масивів, який змінює порядок елементів у масиві на протилежний.",
              "code": "\n// Приклади:\n\n// Реверсування масиву чисел: \nlet numbers = [1, 2, 3, 4, 5];\nnumbers.reverse();\nconsole.log(numbers); // [5, 4, 3, 2, 1]\n\n// Реверсування масиву рядків: \nlet words = ['one', 'two', 'three'];\nwords.reverse();\nconsole.log(words); // ['three', 'two', 'one']\n\n                        ",
              "type": "Array()"
            },
            {
              "name": ".sort()",
              "class": "array",
              "notice": "",
              "description": "sort() є методом масивів в JavaScript, який сортує елементи масиву в порядку зростання. Метод змінює порядок елементів у вихідному масиві.",
              "code": "\n// Приклади використання:\n\n// Сортування масиву чисел:\nlet numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];\nnumbers.sort();\nconsole.log(numbers); \n// Output: [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]\n\n// Сортування масиву рядків:\nlet words = ['apple', 'banana', 'cherry', 'date'];\nwords.sort();\nconsole.log(words); \n// Output: ['apple', 'banana', 'cherry', 'date']\n\n                        ",
              "type": "Array()"
            },
            {
              "name": ".splice()",
              "class": "array",
              "notice": "",
              "description": ".splice() - це метод в JavaScript, який використовується для вставлення або видалення елементів з масиву.",
              "code": "\n// Приклади використання:\n\n// Вставлення елементів:\nlet fruits = ['banana', 'apple', 'mango'];\nfruits.splice(1, 0, 'kiwi', 'grapes');\nconsole.log(fruits);\n// Output: ['banana', 'kiwi', 'grapes', 'apple', 'mango']\n\n// Видалення елементів:\nlet fruits = ['banana', 'apple', 'mango', 'kiwi', 'grapes'];\nfruits.splice(1, 2);\nconsole.log(fruits);\n// Output: ['banana', 'kiwi', 'grapes']\n\n                        ",
              "type": "Array()"
            }
          ]
        },
        "data2": {
          "data1title": "ITERATION METHODS",
          "data3": [
            {
              "name": ".entries()",
              "class": "array",
              "notice": "",
              "description": ".entries() - це метод JavaScript, який використовується для створення об'єкту Array Iterator, який включає в себе пари ключ-значення для кожного елемента в масиві.",
              "code": "\n// Приклад використання:\nlet fruits = ['apple', 'banana', 'cherry'];\nlet fruitEntries = fruits.entries();\n\nconsole.log(fruitEntries.next().value);\n// expected output: [0, \"apple\"]\n\nconsole.log(fruitEntries.next().value);\n// expected output: [1, \"banana\"]\n\n\nlet array1 = ['a', 'b', 'c'];\nlet iterator1 = array1.entries();\n\nfor (let e of iterator1) {\n  console.log(e);\n}\n// expected output:\n// [0, 'a']\n// [1, 'b']\n// [2, 'c']\n\n                        ",
              "type": "Array()"
            },
            {
              "name": ".keys()",
              "class": "array",
              "notice": "",
              "type": "Array()",
              "description": "Array.keys() - це метод JavaScript, який повертає новий об'єкт Array Iterator, який містить ключі для кожного елементу в масиві.",
              "code": "\n// Приклад 1:\nlet масив = [3, 5, 7];\nlet ключі = масив.keys();\nfor (let ключ of ключі) {\n  console.log(ключ);\n}\n// Виводить: 0 1 2\n\n// Приклад 2:\nlet масив = ['Андрей', 'Богдан', 'Віталій'];\nlet ключі = масив.keys();\nfor (let ключ of ключі) {\n  console.log(ключ, масив[ключ]);\n}\n// Виводить: \n// 0 'Андрей'\n// 1 'Богдан'\n// 2 'Віталій'\n\n                        "
            },
            {
              "name": ".values()",
              "class": "array",
              "notice": "",
              "type": "Array()",
              "description": ".values() - це метод JavaScript, який використовується для отримання всіх значень масиву.",
              "code": "\n// Приклади використання:\n\n// Виведення всіх значень масиву:\nlet array = [1, 2, 3, 4, 5];\nlet values = array.values();\n\nfor (let value of values) {\n    console.log(value);\n}\n\n// Використання в комбінації з Array.forEach() для виведення всіх значень масиву:\nlet array = [6, 7, 8, 9, 10];\nlet values = array.values();\n\nvalues.forEach(function(value) {\n    console.log(value);\n});\n\n                        "
            }
          ]
        },
        "data3": {
          "data1title": "CALLBACK FOR EACH METHODS",
          "data4": [
            {
              "name": ".every()",
              "class": "boolean",
              "notice": "test until false",
              "type": "Array()",
              "description": "Array.every() - це метод масиву, який використовується для перевірки всіх елементів масиву на відповідність умові. Метод повертає true, якщо всі елементи відповідають умові, і false, якщо хоча б один елемент не відповідає.",
              "code": "\n//Приклад 1: Перевірка чи всі елементи масиву є додатніми числами\nconst arr = [1, 2, 3, 4, 5];\nconst allPositive = arr.every(function(value) {\n  return value >= 0;\n});\nconsole.log(allPositive);\n// Output: true\n\n// Приклад 2: Перевірка чи всі елементи масиву є строками\nconst arr = ['apple', 'banana', 'cherry'];\nconst allStrings = arr.every(function(value) {\n  return typeof value === 'string';\n});\nconsole.log(allStrings);\n// Output: true\n\n\n                        "
            },
            {
              "name": ".some()",
              "class": "boolean",
              "notice": "test until true",
              "type": "Array()",
              "description": "\"Array.some()\" - це метод масиву JavaScript, який використовується для перевірки, чи є хоча б один елемент масиву відповідає заданим критеріям.",
              "code": "\n// Приклад 1: \"Перевірити, чи є хоча б один елемент масиву більшим за 10\"\nconst arr = [1, 2, 3, 4, 11];\nconst someLarge = arr.some(function(element) {\n  return element > 10;\n});\nconsole.log(someLarge); // true\n\n// Приклад 2: \"Перевірити, чи є хоча б один строковий елемент масиву довжиною більше 5 символів\"\nconst arr = ['dog', 'cat', 'elephant'];\nconst someLong = arr.some(function(element) {\n  return element.length > 5;\n});\nconsole.log(someLong); // true\n\n                        "
            },
            {
              "name": ".map()",
              "class": "array",
              "notice": "make array",
              "type": "Array()",
              "description": "Array.map() - це метод масиву, який викликає певну функцію для кожного елементу масиву та повертає новий масив з результатами виклику. Це дозволяє застосовувати деяку логіку до кожного елементу масиву.",
              "code": "\n// Приклад 1: Збільшення значень елементів масиву на одиницю\nconst numbers = [1, 2, 3, 4, 5];\nconst incrementedNumbers = numbers.map(number => number + 1);\nconsole.log(incrementedNumbers); // [2, 3, 4, 5, 6]\n              "
            },
            {
              "name": ".filter()",
              "class": "array",
              "notice": "make array w/true",
              "type": "Array()",
              "description": "Array.filter() - це метод масиву у JavaScript, який використовується для відфільтрування елементів масиву на основі виконання деякого умовного виразу. Він повертає новий масив, який містить тільки елементи, які пройшли умову.",
              "code": "\n// Приклади:\n\n// Заголовок: Відфільтрувати елементи масиву, які дорівнюють заданому числу\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet filtered = numbers.filter(function (num) {\n  return num === 3;\n});\nconsole.log(filtered); // [3]\n\n// Заголовок: Відфільтрувати елементи масиву, які менше заданого числа\nlet numbers = [1, 2, 3, 4, 5, 6];\nlet filtered = numbers.filter(function (num) {\n  return num < 3;\n});\nconsole.log(filtered); // [1, 2]\n\n                        "
            },
            {
              "name": ".find()",
              "class": "object",
              "notice": "return elem w/true",
              "type": "Array()",
              "description": "Array.find() є методом масиву в JavaScript, який шукає перший елемент в масиві, який відповідає заданому критерію і повертає його. Якщо жоден елемент не відповіє критерію, метод повертає undefined.",
              "code": "\n// Приклад 1: Знайти перший елемент масиву, який дорівнює 5\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst first5 = numbers.find(function(element) {\n  return element === 5;\n});\nconsole.log(first5); // 5\n\n// Приклад 2: Знайти перший об'єкт в масиві, який має свойство name зі значенням \"John\"\nconst users = [\n    { name: \"John\", age: 25 },\n    { name: \"Jane\", age: 30 },\n    { name: \"Jim\", age: 35 }\n  ];\n  const firstJohn = users.find(function(user) {\n    return user.name === \"John\";\n  });\n  console.log(firstJohn); // { name: \"John\", age: 25 }\n  \n"
            },
            {
              "name": ".findIndex()",
              "class": "number",
              "notice": "return index",
              "type": "Array()",
              "description": "Array.findIndex() - це метод масиву JavaScript, який шукає в масиві елемент, який відповідає умові переданій в callback функцію і повертає індекс першого знайденого відповідного елемента.",
              "code": "\n//Приклад 1: Знаходження індексу першого елементу, значення якого перевищує 5\nconst numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9];\nconst firstIndex = numbers.findIndex(num => num > 5);\nconsole.log(firstIndex); // 5\n\n// Приклад 2: Знаходження індексу елементу за його значенням\nconst characters = [{name: 'Naruto', age: 16}, {name: 'Sasuke', age: 17}, {name: 'Sakura', age: 16}];\nconst sakuraIndex = characters.findIndex(char => char.name === 'Sakura');\nconsole.log(sakuraIndex); // 2\n\n                        "
            },
            {
              "name": ".flatMap()",
              "class": "array",
              "notice": "map + flat()",
              "type": "Array()",
              "description": "Array.flatMap() - це метод JavaScript, який використовується для відображення кожного елемента масиву, а потім планує відображений масив в один рядок.",
              "code": "\n// Приклад 1: \"Відображення масиву з властивостями об'єкту\"\nconst arr = [{name: 'John', hobby: ['reading', 'traveling']}, \n            {name: 'Jane', hobby: ['cooking', 'dancing']}];\n\nconst hobbies = arr.flatMap(obj => obj.hobby);\nconsole.log(hobbies); \n// Output: [\"reading\", \"traveling\", \"cooking\", \"dancing\"]\n\n// Приклад 2: \"Розпакування вложених масивів\"\nconst arr = [[1, 2], [3, 4], [5, 6]];\nconst flattenArr = arr.flatMap(x => x);\nconsole.log(flattenArr); \n// Output: [1, 2, 3, 4, 5, 6]\n\n                        "
            },
            {
              "name": ".forEach()",
              "class": "undefined",
              "notice": "exec for each",
              "type": "Array()",
              "description": "Array.forEach() є методом в javascript, який викликає функцію обробника для кожного елемента масиву. Цей метод не повертає значення, він лише виконує дію для кожного елемента.",
              "code": "\n // Приклади використання:\n\n// Заголовок: Виведення всіх елементів масиву на екран\nconst numbers = [1, 2, 3, 4];\n\nnumbers.forEach(function(num) {\n  console.log(num);\n});\n\n// Output:\n// 1\n// 2\n// 3\n// 4\n\n// Заголовок: Розширення масиву і додавання в нього нових елементів\nconst numbers = [1, 2, 3, 4];\nconst doubledNumbers = [];\n\nnumbers.forEach(function(num) {\n  doubledNumbers.push(num * 2);\n});\n\nconsole.log(doubledNumbers);\n\n// Output:\n// [2, 4, 6, 8]\n\n                        "
            },
            {
              "name": ".reduce()",
              "class": "object",
              "notice": "accumulative",
              "type": "Array()",
              "description": "Array.reduce() є методом в javascript, який викликає функцію обробника для кожного елемента масиву. Цей метод не повертає значення, він лише виконує дію для кожного елемента.",
              "code": "\nconst array = [1, 2, 3, 4];\n\n// Приклад 1: Рахує суму всіх елементів масиву\nconst sum = array.reduce((acc, cur) => acc + cur, 0);\nconsole.log(sum); // 10\n\n// \"Рахує суму всіх елементів масиву\"\n// acc - поточний акумулятор, cur - поточний елемент масиву\n\n// Приклад 2: Знаходить максимальний елемент в масиві\nconst max = array.reduce((acc, cur) => acc > cur ? acc : cur);\nconsole.log(max); // 4\n\n// \"Знаходить максимальний елемент в масиві\"\n//  acc - поточний максимальний елемент, cur - поточний елемент масиву\n\n                        "
            },
            {
              "name": ".reduceRight()",
              "class": "object",
              "notice": "from end",
              "type": "Array()",
              "description": "\"Array.reduceRight()\" в JavaScript є методом масиву, який приймає функцію обробника та використовує її для виконання деякої дії для кожного елемента масиву, починаючи з останнього елемента та до першого. Цей метод повертає одне значення, яке залежить від викликаної функції обробника.",
              "code": "\n// Приклад 1: \"Сумування всіх елементів масиву\"\nlet numbers = [1, 2, 3, 4, 5];\nlet sum = numbers.reduceRight((acc, curr) => acc + curr);\nconsole.log(sum); // 15\n\n// Приклад 2: \"Об'єднання всіх елементів масиву у рядок\"\nlet words = ['я', 'розумію', 'це'];\nlet sentence = words.reduceRight((acc, curr) => curr + ' ' + acc);\nconsole.log(sentence); // \"це розумію я\"\n\n                        "
            }
          ]
        },
        "data4": {
          "data1title": "ADD/REMOVE METHODS",
          "data5": [
            {
              "name": ".pop()",
              "class": "object",
              "notice": "",
              "type": "Array()",
              "description": "\"Array.pop()\" - це метод масиву в JavaScript, який видаляє останній елемент масиву та повертає його значення.",
              "code": "\n// Видалення останнього елементу масиву\nconst animals = ['dog', 'cat', 'rabbit', 'parrot'];\n\nconst lastAnimal = animals.pop();\nconsole.log(animals); // [ 'dog', 'cat', 'rabbit' ]\nconsole.log(lastAnimal); // 'parrot'\n\n// Використання у циклі\nconst numbers = [1, 2, 3, 4, 5];\n\nwhile (numbers.length > 0) {\n    console.log(numbers.pop());\n    // 5\n    // 4\n    // 3\n    // 2\n    // 1\n}\n\n                        "
            },
            {
              "name": ".push()",
              "class": "number",
              "notice": "",
              "type": "Array()",
              "description": "Array.push() є методом в javascript, який додає один або кілька елементів в кінець масиву.",
              "code": "\n// Приклад 1: Додати один елемент в кінець масиву\nlet fruits = ['Apple', 'Banana'];\nfruits.push('Cherry');\nconsole.log(fruits); // виведе: ['Apple', 'Banana', 'Cherry']\n\n// Приклад 2: Додати кілька елементів в кінець масиву\nlet fruits = ['Apple', 'Banana'];\nfruits.push('Cherry', 'Durian');\nconsole.log(fruits); // виведе: ['Apple', 'Banana', 'Cherry', 'Durian']\n\n                        "
            },
            {
              "name": ".shift()",
              "class": "object",
              "notice": "",
              "type": "Array()",
              "description": "Array.shift() є методом в javascript, який видаляє перший елемент масиву та повертає його значення.",
              "code": "\n// Приклад 1: Видалення першого елемента масиву\nvar fruits = ['apple', 'banana', 'cherry'];\nvar firstFruit = fruits.shift();\nconsole.log(fruits); // ['banana', 'cherry']\nconsole.log(firstFruit); // 'apple'\n\n//Приклад 2: Використання shift() для видалення елементів з масиву доки він не стане пустим\nvar numbers = [1, 2, 3, 4, 5];\nwhile (numbers.length > 0) {\n  console.log(numbers.shift());\n}\n// Output: 1 2 3 4 5\n\n                        "
            },
            {
              "name": ".unshift()",
              "class": "number",
              "notice": "",
              "type": "Array()",
              "description": "Array.unshift() - це метод в JavaScript, який додає елементи на початок масиву та повертає нову довжину масиву.",
              "code": "\n// Приклад 1: \"Додавання елементів в початок масиву\"\nlet fruits = ['banana', 'apple'];\nconsole.log(fruits.unshift('pear', 'mango'));\nconsole.log(fruits); \n// Output: 4\n// ['pear', 'mango', 'banana', 'apple']\n\n// Приклад 2: \"Додавання одного елемента в початок масиву\"\nlet numbers = [2, 3, 4, 5];\nconsole.log(numbers.unshift(1));\nconsole.log(numbers); \n// Output: 5\n// [1, 2, 3, 4, 5]\n                        "
            }
          ]
        }
      }
    },
    {
      "titleBlock": "JSON",
      "properties": [],
      "methods": {
        "basicMethods": [
          {
            "name": ".parse()",
            "class": "object",
            "notice": "",
            "description": ".parse() - це метод JavaScript, який використовується для перетворення рядкового представлення JSON на об'єкт JavaScript.",
            "code": "\n//  Приклад 1 \nlet jsonString = '{\"name\": \"John\", \"age\": 30, \"city\": \"New York\"}';\nlet obj = JSON.parse(jsonString);\nconsole.log(obj.name); // \"John\"\n\n// Приклад 2\nlet str = '[1, 2, 3, 4, 5]';\nlet numbers = JSON.parse(str);\nconsole.log(numbers[0]); // 1\n\n                    ",
            "type": "JSON"
          },
          {
            "name": ".stringify() ",
            "class": "object",
            "notice": "",
            "description": "JSON.stringify() - це метод JavaScript, який конвертує JavaScript-об'єкт або масив в рядок JSON (JavaScript Object Notation).",
            "code": "\n// Приклади використання:\n\n// Конвертація об'єкту в рядок JSON:\nconst object = {name: 'John', age: 30};\nconst json = JSON.stringify(object);\nconsole.log(json); // '{\"name\":\"John\",\"age\":30}'\n\n// Конвертація масиву в рядок JSON:\n\nconst array = [1, 2, 3];\nconst json = JSON.stringify(array);\nconsole.log(json); // '[1,2,3]'\n\n                    ",
            "type": "JSON"
          }
        ],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "Promise()",
      "properties": [],
      "methods": {
        "basicMethods": [{
          "name": ".all(obj)",
          "class": "promise",
          "notice": "",
          "description": "Метод Promise.all() у JavaScript приймає масив обіцянок (promises) і повертає нову обіцянку, яка виконується тільки тоді, коли всі передані обіцянки виконані.",
          "code": "\n// Приклад 1:\n// Масив обіцянок\nconst promises = [\n  Promise.resolve('Перша обіцянка'),\n  Promise.resolve('Друга обіцянка'),\n  Promise.resolve('Третя обіцянка')\n];\n\n// Promise.all повертає нову обіцянку, яка виконується тільки після виконання всіх переданих обіцянок\nPromise.all(promises)\n  .then(results => {\n    console.log(results); // [\"Перша обіцянка\", \"Друга обіцянка\", \"Третя обіцянка\"]\n  })\n  .catch(error => {\n    console.error(error);\n  });\n\n// Приклад 2:\n// Функція, яка повертає обіцянку\nfunction getData(url) {\n  return fetch(url)\n    .then(response => response.json());\n}\n\n// Масив з URL\nconst urls = [\n  'https://jsonplaceholder.typicode.com/todos/1',\n  'https://jsonplaceholder.typicode.com/todos/2',\n  'https://jsonplaceholder.typicode.com/todos/3'\n];\n\n// Promise.all повертає нову обіцянку, яка виконується тільки після виконання всіх переданих обіцянок\nPromise.all(urls.map(url => getData(url)))\n  .then(results => {\n    console.log(results); // масив з результатами\n  })\n  .catch(error => {\n    console.error(error);\n  });\n\n\n",
          "type": "Promise()"
        }, {
          "name": ".catch()",
          "class": "promise",
          "notice": "",
          "description": "Метод Promise.catch() використовується для обробки помилок, які виникають при виконанні обіцянки (Promise). Якщо в Promise виникає помилка, яка не обробляється методом then(), контроль передається до методу catch(), де можна виконати необхідні дії для обробки помилки.",
          "code": "\n// Приклад 1: Обробка помилок за допомогою Promise.catch()\nfunction doSomething() {\n    return new Promise((resolve, reject) => {\n      // Випадкова помилка\n      if (Math.random() < 0.5) {\n        reject(\"Помилка: щось пішло не так!\");\n      } else {\n        resolve(\"Успіх: все пройшло гладко!\");\n      }\n    });\n  }\n  \n  doSomething()\n    .then(result => {\n      console.log(result);\n    })\n    .catch(error => {\n      console.error(error);\n    });\n\n",
          "type": "Promise()"
        }, {
          "name": ".finally()",
          "class": "promise",
          "notice": "",
          "description": "Promise.finally() - це метод, який виконує деякий код після виконання Promise, незалежно від того, чи він виконався успішно, чи призвів до помилки. Цей метод не приймає жодного аргументу та повертає той самий Promise, що й переданий до нього.",
          "code": "\n// Ось два приклади використання Promise.finally():\n\n// Приклад 1: Використання Promise.finally() для закриття з'єднання з базою даних\n// Встановлюємо з'єднання з базою даних\nlet db = openDatabase('mydb', '1.0', 'Test DB', 2 * 1024 * 1024);\n\n// Виконуємо запит до бази даних\nlet queryPromise = new Promise((resolve, reject) => {\n  db.transaction(function (tx) {\n    tx.executeSql('SELECT * FROM users', [], function (tx, results) {\n      resolve(results.rows);\n    }, function (tx, error) {\n      reject(error);\n    });\n  });\n});\n\n// Додаємо функцію finally, яка закриє з'єднання з базою даних\nqueryPromise.finally(() => {\n  db.close();\n});\n\n// Приклад 2: Використання Promise.finally() для приховання індікатора завантаження,\n// Показуємо індікатор завантаження\nshowLoadingIndicator();\n\n// Виконуємо запит до сервера\nlet dataPromise = fetch('/api/data')\n  .then(response => response.json())\n  .catch(error => console.error(error))\n  .finally(() => {\n    // Ховаємо індікатор завантаження\n    hideLoadingIndicator();\n  });\n\n",
          "type": "Promise()"
        }, {
          "name": ".then()",
          "class": "promise",
          "notice": "",
          "description": "Метод Promise.then() використовується для додавання обробників до обіцянки (promise), які будуть виконані, коли обіцянка виконається успішно.\n\n                Опис параметрів:\n                \n                    onFulfilled (обов'язковий): функція, яка буде виконана при успішному виконанні обіцянки. Приймає один аргумент - результат виконання обіцянки.\n                    onRejected (необов'язковий): функція, яка буде виконана, якщо обіцянка не виконається успішно. Приймає один аргумент - причину неуспішного виконання обіцянки.\n                \n                Повертає нову обіцянку, результатом якої є значення, яке повернуто з функції onFulfilled або onRejected.",
          "code": "\n// Приклади використання:\n\n// Приклад 1: Виведення результату виконання обіцянки у консоль\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"Успіх!\");\n  }, 1000);\n});\n\npromise.then((result) => {\n  console.log(result); // \"Успіх!\"\n});\n\n\n// Приклад 2: Обробка помилки\nconst promise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(new Error(\"Помилка!\"));\n  }, 1000);\n});\n\npromise.then(\n  (result) => {\n    // Цей обробник не виконається\n  },\n  (error) => {\n    console.log(error.message); // \"Помилка!\"\n  }\n);\n\n",
          "type": "Promise()"
        }, {
          "name": ".race()",
          "class": "promise",
          "notice": "",
          "description": "Promise.race() - це метод, що приймає масив об'єктів Promise і повертає новий об'єкт Promise, який вирішується або відхиляється при першому завершенні будь-якого з переданих Promise.",
          "code": "\n//Ось два приклади використання Promise.race():\n\n// Приклад 1:\nconst promise1 = new Promise((resolve, reject) => {\n    setTimeout(resolve, 500, 'перший проміс');\n  });\n  \n  const promise2 = new Promise((resolve, reject) => {\n    setTimeout(resolve, 100, 'другий проміс');\n  });\n  \n  Promise.race([promise1, promise2]).then((result) => {\n    console.log(result); // виведе \"другий проміс\"\n  });\n\n//  У цьому прикладі метод Promise.race() приймає масив двох об'єктів Promise: promise1 і promise2. promise1 вирішується через 500 мс, а promise2 - через 100 мс.\n// Метод Promise.race() повертає новий Promise, який вирішується при першому завершенні будь-якого з переданих Promise. \n// У даному випадку, promise2 завершується раніше, тому виведеться результат другий проміс.\n\n// Приклад 2:\nconst promise1 = new Promise((resolve, reject) => {\n    setTimeout(resolve, 1000, 'перший проміс');\n  });\n  \n  const promise2 = new Promise((resolve, reject) => {\n    setTimeout(reject, 500, 'другий проміс');\n  });\n  \n  Promise.race([promise1, promise2]).then((result) => {\n    console.log(result);\n  }).catch((error) => {\n    console.log(error); // виведе \"другий проміс\"\n  });\n\n\n// У цьому прикладі метод Promise.race() також приймає масив двох об'єктів Promise: promise1 і promise2. \n// Але в цьому випадку promise2 відхиляється через 500 мс, а promise1 вирішується через 1000 мс. \n// Тому Promise.race() поверне новий Promise, який відхилиться при першому відхиленні будь-якого з переданих Promise. \n// У цьому випадку promise2 відхиляється раніше, тому результатом буде відхилення з повідомленням \"другий проміс\"\n",
          "type": "Promise()"
        }, {
          "name": ".resolve()",
          "class": "promise",
          "notice": "",
          "description": "Метод Promise.resolve() повертає обіцянку, що виконалася з вказаним значенням. Якщо значення є обіцянкою, повертається та ж обіцянка.",
          "code": "\n// Приклад 1: Розділити рядок на слова та створити з кожного слова об'єкт з ключем word і додатковою властивістю length, яка містить довжину слова.\nconst str = \"Привіт світ\";\nconst words = str.split(\" \");\n\nconst wordObjects = words.map(word => Promise.resolve(word).then(val => ({ word: val, length: val.length })));\n\nPromise.all(wordObjects).then(console.log); // виведе [{ word: \"Привіт\", length: 6 }, { word: \"світ\", length: 4 }]\n\n\n// Приклад 2: Створення обіцянки зі значенням 42 і обробка її результату:\nconst promise = Promise.resolve(42);\n\npromise.then(value => {\n  console.log(value); // виведе 42\n});\n\npromise.catch(error => {\n  console.error(error); // не буде викликано, оскільки обіцянка завершилася успішно\n});\n\n// У цьому прикладі Promise.resolve(42) повертає обіцянку, яка вже виконалася зі значенням 42. \n// Після того, як обіцянка була створена, можна прикріпити обробники then та catch до обіцянки, щоб обробити її результат або помилку.\n\n",
          "type": "Promise()"
        }, {
          "name": ".reject()",
          "class": "promise",
          "notice": "",
          "description": "Метод Promise.reject(reason) створює об'єкт Promise, який буде відхилений з заданою причиною (reason).",
          "code": "\n// Синтаксис: Promise.reject(reason)\n// Параметри:\n\n// reason: значення, що буде передано як причина відхилення об'єкта Promise\n\n// Повертає: новий об'єкт Promise, який буде відхилений з заданою причиною.\n\n// Приклад 1: Створення відхилених Promise\n// Створення відхилених Promise з різними причинами\nconst rejectedPromise1 = Promise.reject(\"Помилка 1\");\nconst rejectedPromise2 = Promise.reject(\"Помилка 2\");\n\n// Обробка відхилення Promise\nrejectedPromise1.catch((error) => console.log(\"Помилка 1:\", error));\nrejectedPromise2.catch((error) => console.log(\"Помилка 2:\", error));\n\n// Приклад 2: Використання Promise.reject() разом з Promise.all()\n// Створення Promise, який завжди буде відхилено\nconst rejectedPromise = Promise.reject(\"Помилка\");\n\n// Створення масиву Promise, який містить об'єкт 'rejectedPromise'\nconst promises = [Promise.resolve(\"Завершено 1\"), rejectedPromise, Promise.resolve(\"Завершено 2\")];\n\n// Виконання Promise.all() з масивом Promise\nPromise.all(promises)\n  .then((results) => console.log(results)) // Ніколи не буде виконано\n  .catch((error) => console.log(\"Помилка:\", error)); // Виконається, і виведе причину відхилення rejectedPromise\n",
          "type": "Promise()"
        }, {
          "name": ".allSettled()",
          "class": "promise",
          "notice": "",
          "description": "Метод Promise.allSettled() очікує на масив обіцянок (promises) та повертає нову обіцянку, яка вирішується, коли всі передані обіцянки вирішаться, незалежно від їхнього результату. Повернутий результат є масивом об'єктів, де кожен об'єкт містить статус обіцянки та її результат або причину відхилення.",
          "code": "\n//Ось два приклади використання методу Promise.allSettled():\n\n// Приклад 1:\nconst promises = [\n    Promise.resolve(1),\n    Promise.reject('Error'),\n    Promise.resolve(3)\n  ];\n  \n  Promise.allSettled(promises)\n    .then(results => console.log(results));\n\n// Коментар: У цьому прикладі ми створюємо масив обіцянок з двох успішно виконаних та однієї відхиленої обіцянок. \n// Ми викликаємо метод Promise.allSettled() з цим масивом обіцянок та виводимо результат в консоль.\n//  У нашому випадку результат буде масив об'єктів із станом кожної обіцянки та її значеннями або причинами відхилення.\n\n\n// Приклад 2:\nconst promises = [\n    fetch('https://jsonplaceholder.typicode.com/todos/1'),\n    fetch('https://jsonplaceholder.typicode.com/todos/2'),\n    fetch('https://jsonplaceholder.typicode.com/todos/3')\n  ];\n  \n  Promise.allSettled(promises)\n    .then(results => {\n      results.forEach(result => {\n        if (result.status === 'fulfilled') {\n          console.log(`Результат: ${result.value}`);\n        } else {\n          console.log(`Причина відхилення: ${result.reason}`);\n        }\n      });\n    });\n  \n// Коментар: У цьому прикладі ми використовуємо метод Promise.allSettled() для запиту до трьох URL-адрес на jsonplaceholder.typicode.com та виводимо результат в консоль.\n// Оскільки Promise.allSettled() обробляє всі обіцянки незалежно від їхнього результату, то ми можемо перевірити кожен об'єкт результатів в масиві та вивести результат чи причину відхилення в залежності від стану обіцянки.\n",
          "type": "Promise()"
        }],
        "data1": {
          "data1title": "",
          "data2": []
        },
        "data2": {
          "data1title": "",
          "data3": []
        },
        "data3": {
          "data1title": "",
          "data4": []
        },
        "data4": {
          "data1title": "",
          "data5": []
        }
      }
    },
    {
      "titleBlock": "Error()",
      "properties": [
        {
          "name": ".name",
          "class": "string",
          "description": "Error.name - це властивість в JavaScript, яка повертає ім'я типу помилки. Це строкове значення, яке показує, який тип помилки виник.",
          "code": "\n// Приклад використання:\ntry {\n    throw new Error('This is a custom error');\n  } catch (error) {\n    console.log(error.name); // \"Error\"\n  }\n\n// Інший приклад:\nconst customError = new TypeError('Invalid data type');\n\nconsole.log(customError.name); // \"TypeError\"\n\n                ",
          "type": "Error()"
        },
        {
          "name": ".message",
          "class": "string",
          "description": "Error.message - це властивість в JavaScript, яка повертає повідомлення про помилку. Це строкове значення, яке містить деталі про помилку.",
          "code": "\n// Приклад використання:\ntry {\n    throw new Error('This is a custom error');\n  } catch (error) {\n    console.log(error.message); // \"This is a custom error\"\n  }\n\n// Інший приклад: \nconst customError = new TypeError('Invalid data type');\n\nconsole.log(customError.message); // \"Invalid data type\"\n\n",
          "type": "Error()"
        }
      ],
      "methods": {
        "basicMethods": [],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "Symbol",
      "properties": [
        {
          "name": ".iterator",
          "class": "array",
          "description": "Symbol.iterator - це спеціальний символ в JavaScript, який визначає функцію ітератора для об'єкту. Функція ітератора повертає об'єкт, який можна використовувати для перебору елементів об'єкту.",
          "code": "\n// Приклад використання:\nconst numbers = [1, 2, 3, 4];\n\nconst iterator = numbers[Symbol.iterator]();\n\nconsole.log(iterator.next().value); // 1\nconsole.log(iterator.next().value); // 2\n\n// Інший приклад:\nconst data = {\n    name: 'John Doe',\n    age: 30,\n    [Symbol.iterator]: function() {\n      const properties = Object.keys(this);\n      let count = 0;\n      return {\n        next: function() {\n          if (count < properties.length) {\n            return {\n              value: [properties[count], this[properties[count++]]],\n              done: false\n            };\n          } else {\n            return { done: true };\n          }\n        }.bind(this)\n      };\n    }\n  };\n  \n  const iterator = data[Symbol.iterator]();\n  \n  console.log(iterator.next().value); // [\"name\", \"John Doe\"]\n  console.log(iterator.next().value); // [\"age\", 30]\n  \n",
          "type": "Symbol"
        },
        {
          "name": ".match",
          "class": "string",
          "description": "Symbol.match - це спеціальний символ в JavaScript, який визначає метод для строки, який використовується при використанні регулярних виразів.",
          "code": "\n// Приклад використання:\nconst text = 'Hello World';\nconst regex = /Hello/;\n\nregex[Symbol.match] = function() {\n  return 'Goodbye';\n};\n\nconsole.log(text.match(regex)); // Goodbye\n\n// Інший приклад:\nconst data = {\n    name: 'John Doe',\n    age: 30,\n    [Symbol.match]: function(value) {\n      return value === this.name;\n    }\n  };\n  \n  console.log('John Doe'.match(data)); // John Doe\n  console.log('Jane Doe'.match(data)); // null\n  \n\n                ",
          "type": "Symbol"
        },
        {
          "name": ".species",
          "class": "string",
          "description": "Symbol.species - це спеціальний символ в JavaScript, який визначає конструктор, який використовується при створенні нащадків поточного об'єкта.",
          "code": "\n// Приклад використання:\nclass MyArray extends Array {\n    static get [Symbol.species]() {\n      return Array;\n    }\n  }\n  \n  const myArray = new MyArray(1, 2, 3);\n  const myArrayClone = myArray.map(x => x);\n  \n  console.log(myArrayClone instanceof MyArray); // false\n  console.log(myArrayClone instanceof Array); // true\n\n// Інший приклад:\nclass MyPromise extends Promise {\n    static get [Symbol.species]() {\n      return Promise;\n    }\n  }\n  \n  const myPromise = new MyPromise((resolve, reject) => {\n    resolve(123);\n  });\n  \n  const myPromiseClone = myPromise.then(x => x);\n  \n  console.log(myPromiseClone instanceof MyPromise); // false\n  console.log(myPromiseClone instanceof Promise); // true\n  \n                ",
          "type": "Symbol"
        }
      ],
      "methods": {
        "basicMethods": [
          {
            "name": ".for(key)",
            "class": "string",
            "description": "Symbol.for(key) - це статичний метод символу, який створює глобальний символ з вказаним ключем. Якщо символ з таким ключем вже існує, то він буде повернений, якщо немає, то він буде створений.",
            "code": "\n\nlet sym1 = Symbol.for(\"key\");\nlet sym2 = Symbol.for(\"key\");\nconsole.log(sym1 === sym2); // true\n                    ",
            "type": "Symbol"
          },
          {
            "name": ".keyFor(sym) ",
            "class": "string",
            "description": "Symbol.keyFor(sym) є методом, який повертає ключ, відповідний до символу sym, який було створено за допомогою Symbol.for(key).",
            "code": "\n// Приклад 1:\nconst sym = Symbol.for(\"example\");\nconsole.log(Symbol.keyFor(sym)); // \"example\"\n\n// Приклад 2:\nconst sym = Symbol(\"example\");\nconsole.log(Symbol.keyFor(sym)); // undefined\n\n",
            "type": "Symbol"
          }
        ],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "window",
      "properties": [],
      "methods": {
        "basicMethods": [
          {
            "name": ".alert(str)",
            "class": "undefined",
            "description": ".alert() - це метод в JavaScript, який призначений для створення вспливаючого вікна (alert box) в браузері. Він приймає рядок тексту як параметр, який відображається в вікні попередження.",
            "code": "\n// Приклад використання:\nalert(\"Hello, World!\");\n\n// Це відобразить вспливаюче вікно з повідомленням \"Hello, World!\".\n\n// Ще один приклад:\nvar name = prompt(\"What is your name?\");\nalert(\"Hello, \" + name + \"!\");\n\n// Це відобразить вспливаюче вікно з запитанням \"What is your name?\" \n// і відображає вітання вспливаючому вікні в залежності від введеного в поле вводу користувачем значення.\n\n",
            "type": "window"
          },
          {
            "name": ".prompt(str, def)",
            "class": "string",
            "description": ".prompt(str, def) - це метод JavaScript, який відображає вікно введення з повідомленням str та заповнює його значенням за замовчуванням def. Користувач може ввести своє значення та натиснути \"OK\", щоб повернути його.",
            "code": "\n// Приклади використання:\n\n// Запитати ім'я користувача:\nvar userName = prompt(\"Введіть своє ім'я:\", \"Анонімний\");\nconsole.log(\"Вітаю, \" + userName);\n\n// Запитати вік користувача:\nvar userAge = prompt(\"Введіть свій вік:\", \"0\");\nconsole.log(\"Ваш вік: \" + userAge);\n\n\n                    ",
            "type": "window"
          },
          {
            "name": ".confirm(str)",
            "class": "boolean",
            "description": ".confirm(str) - це метод JavaScript, який відображає діалогове вікно з підтвердженням. Він приймає один аргумент str, який є рядком повідомлення, яке буде відображене в діалоговому вікні. Метод повертає true, якщо користувач натиснув кнопку \"OK\", в іншому випадку він повертає false.",
            "code": "\n// Приклади використання:\n// Приклад 1:\nlet result = confirm(\"Ви впевнені, що хочете видалити файл?\");\nif (result) {\n  console.log(\"Файл видалено\");\n} else {\n  console.log(\"Видалення файлу скасовано\");\n}\n\n//  Приклад 2:\nlet age = prompt(\"Введіть ваш вік\");\nif (age >= 18) {\n  console.log(\"Ви можете відвідувати сайт\");\n} else {\n  console.log(\"Вам недоступний цей сайт\");\n}\n",
            "type": "window"
          }
        ],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "Map()",
      "properties": [
        {
          "name": ".size",
          "class": "number",
          "description": "Map.size є властивістю об'єкту Map, яка відображає кількість елементів у Map.",
          "code": "\n// Приклад використання:\nconst map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\nconsole.log(map.size); // 2\n\n\nconst map = new Map([['name', 'John'], ['age', 30]]);\nconsole.log(map.size); // 2\n\n",
          "type": "Map()"
        }
      ],
      "methods": {
        "basicMethods": [
          {
            "name": ".set(key, value)",
            "class": "map",
            "description": "Map.set - це метод, який використовується для додавання або оновлення пари ключ-значення в об'єкті Map.",
            "code": "\n// Приклад використання:\nlet map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\nconsole.log(map);\n// Map { 'name' => 'John', 'age' => 30 }\n                \n// Ще один приклад:\nlet map = new Map();\nmap.set('name', 'Jane');\nmap.set('age', 25);\nmap.set('name', 'John');\n console.log(map);\n// Map { 'name' => 'John', 'age' => 25 }\n                \n// У першому прикладі ми додали дві пари ключ-значення, а у другому - ми оновили значення ключа 'name'.\n                ",
            "type": "Map()"
          },
          {
            "name": ".get(key)",
            "class": "object",
            "description": ".get(key) - це метод Map в JavaScript, який дозволяє отримати значення відповідно до певного ключа.",
            "code": "\n// Приклад використання:\nconst map1 = new Map();\nmap1.set(\"name\", \"John\");\nmap1.set(\"age\", 30);\n                \nconsole.log(map1.get(\"name\")); // John\nconsole.log(map1.get(\"age\")); // 30\n                \n// Інший приклад використання:\nconst map2 = new Map([\n[\"name\", \"Jane\"],\n[\"age\", 25]\n]);\n                \nconsole.log(map2.get(\"name\")); // Jane\nconsole.log(map2.get(\"age\")); // 25\n                \n                    ",
            "type": "Map()"
          },
          {
            "name": ".has(key)",
            "class": "boolean",
            "description": ".has(key) - це метод Map об'єкту в JavaScript, який перевіряє, чи існує відповідний ключ у колекції. Він повертає логічне значення true або false в залежності від того, чи існує ключ в колекції.",
            "code": "\n// Приклади використання:\nlet map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\n                \n// Перевіряємо, чи існує ключ 'name'\nconsole.log(map.has('name')); // true\n                \n// Перевіряємо, чи існує ключ 'job'\nconsole.log(map.has('job')); // false\n                \n                \nlet map = new Map();\nmap.set('name', 'Jane');\nmap.set('age', 25);\n                \nlet keys = Array.from(map.keys());\n                \n// Перевіряємо, чи існує ключ 'name' в масиві ключів\nconsole.log(keys.includes('name')); // true\n                \n// Перевіряємо, чи існує ключ 'job' в масиві ключів\nconsole.log(keys.includes('job')); // false\n                \n                \n                ",
            "type": "Map()"
          },
          {
            "name": ".delete(key)",
            "class": "boolean",
            "description": "Map.delete(key) - метод видаляє елемент з Map, що відповідає вказаному ключу.",
            "code": "\n// Приклад 1\nlet myMap = new Map();\nmyMap.set('name', 'John');\nmyMap.set('age', 30);\nmyMap.delete('age');\nconsole.log(myMap); // Map { 'name' => 'John' }\n                    \n// Приклад 2\nlet myMap = new Map([['name', 'John'], ['age', 30]]);\nmyMap.delete('age');\nconsole.log(myMap); // Map { 'name' => 'John' }\n                    \n                ",
            "type": "Map()"
          },
          {
            "name": ".clear()",
            "class": "map",
            "description": ".clear() - це метод, який видаляє всі елементи з карти (Map) у JavaScript.",
            "code": "\n// Приклад 1:\nlet map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\nconsole.log(map.size); // 2\n                \n map.clear();\nconsole.log(map.size); // 0\n                \n// Приклад 2:\nlet map = new Map();\nmap.set('name', 'Jane');\nmap.set('age', 25);\n                \nif (map.has('name')) {\nmap.clear();\n}\nconsole.log(map.size); // 0\n                \n                \n                ",
            "type": "Map()"
          }
        ],
        "data1": {
          "data1title": "ITERATION METHODS",
          "data2": [
            {
              "name": ".entries()",
              "class": "map",
              "description": "Map.entries() - це метод JavaScript, який повертає масив всіх ключ-значення пар в об'єкті Map.",
              "code": "\n// Приклад використання:\nconst map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\n\nconst entries = map.entries();\nconsole.log(entries); // [['name', 'John'], ['age', 30]]\n\n",
              "type": "Map()"
            },
            {
              "name": ".keys()",
              "class": "map",
              "description": ".keys() - це метод в JavaScript, який використовується для повернення всіх ключів у відображення (Map). Це відображення має метод .keys(), який повертає об'єкт, який містить всі ключі у відображенні.",
              "code": "\n// Приклади:\n// 1:\nlet myMap = new Map();\nmyMap.set(\"name\", \"John\");\nmyMap.set(\"age\", 30);\nmyMap.set(\"job\", \"developer\");\n\nlet keys = myMap.keys();\nconsole.log(keys);\n// Output: MapIterator {\"name\", \"age\", \"job\"}\n\n// 2:\nlet myMap = new Map([\n    [\"name\", \"John\"],\n    [\"age\", 30],\n    [\"job\", \"developer\"]\n  ]);\n  \n  let keys = myMap.keys();\n  for (let key of keys) {\n    console.log(key);\n  }\n  // Output:\n  // \"name\"\n  // \"age\"\n  // \"job\"\n  \n",
              "type": "Map()"
            },
            {
              "name": ".values()",
              "class": "map",
              "description": ".values() - це метод об'єкту Map, який повертає колекцію значень всіх елементів у відомому об'єкті Map.",
              "code": "\n// Приклад 1:\nlet map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\n\nlet values = map.values();\nfor (let value of values) {\n  console.log(value);\n}\n// Output: John, 30\n\n// Приклад 2:\nlet map = new Map();\nmap.set('product1', 'iPhone');\nmap.set('product2', 'Macbook');\n\nlet values = Array.from(map.values());\nconsole.log(values);\n// Output: [iPhone, Macbook]\n\n                        ",
              "type": "Map()"
            }
          ]
        },
        "data2": {
          "data1title": "CALLBACK FOR EACH METHODS",
          "data3": [
            {
              "name": ".forEach()",
              "class": "undefined",
              "description": ".forEach() - це метод класу Map, який викликає функцію для кожного елемента в колекції.",
              "code": "\n// Опис використання:\nmap.forEach(function(value, key, map) {\n    // code to be executed\n  });\n\n\n// value - значення поточного елемента в колекції.\n// key - ключ поточного елемента в колекції.\n// map - сама колекція Map.\n\n// Приклади використання:\n// Виведення всіх значень в консоль:\nlet map = new Map();\nmap.set('name', 'John');\nmap.set('age', 30);\n\nmap.forEach(function(value, key) {\n  console.log(key + ': ' + value);\n});\n\n// Output:\n// name: John\n// age: 30\n\n// Знаходження суми всіх значень:\nlet map = new Map();\nmap.set('apples', 10);\nmap.set('bananas', 5);\nmap.set('oranges', 8);\n\nlet sum = 0;\n\nmap.forEach(function(value) {\n  sum += value;\n});\n\nconsole.log('Total fruits: ' + sum);\n\n// Output:\n// Total fruits: 23\n\n\n                        ",
              "type": "Map()"
            }
          ]
        },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "Set()",
      "properties": [
        {
          "name": ".size()",
          "class": "number",
          "description": "Set().size - це метод JavaScript, який використовується для визначення розміру множини (Set).",
          "code": "\n// Приклади використання Set().size:\n\n// Визначення розміру множини:\nvar set = new Set(['apple', 'banana', 'cherry']);\nconsole.log(set.size); // виведе 3\n\n// Використання розміру множини для циклу:\nvar set = new Set([1, 2, 3, 4, 5]);\nfor (var i = 0; i < set.size; i++) {\n  console.log(set[i]);\n}\n                ",
          "type": "Set()"
        }
      ],
      "methods": {
        "basicMethods": [
          {
            "name": ".add()",
            "class": "string",
            "description": "Set().add() - це метод, який додає елемент в множину Set у JavaScript. Метод повертає нову множину, в якій доданий елемент.",
            "code": "\n// Приклад 1: Додавання елементів в множину Set\n// Створення множини\nlet set = new Set();\n\n// Додавання елементів в множину\nset.add(1);\nset.add(2);\nset.add(3);\n\nconsole.log(set); // Set { 1, 2, 3 }\n\n\n//Приклад 2: Додавання повторяючихся елементів в множину Set\n// Створення множини\nlet set = new Set();\n\n// Додавання елементів в множину\nset.add(1);\nset.add(2);\nset.add(3);\nset.add(1);\n\nconsole.log(set); // Set { 1, 2, 3 }\n\n\n",
            "type": "Set()"
          },
          {
            "name": ".has(item)",
            "class": "boolean",
            "description": "Set().has()  у JavaScript - це метод для перевірки наявності елемента у множині. Він повертає true, якщо елемент знаходиться у множині, і false в іншому випадку.",
            "code": "\n//  Приклад 1: \"Перевірка наявності елементу у множині\"\nlet fruits = new Set([\"apple\", \"banana\", \"orange\"]);\n\n// Перевіряємо чи є в множині елемент \"apple\"\nlet hasApple = fruits.has(\"apple\");\nconsole.log(hasApple); // true\n\n// Перевіряємо чи є в множині елемент \"grape\"\nlet hasGrape = fruits.has(\"grape\");\nconsole.log(hasGrape); // false\n\n// Приклад 2: \"Використання has() для перевірки відсутності повторюваних значень у масиві\"\nlet numbers = [1, 2, 3, 4, 5, 1, 2, 3];\n\n// Перетворюємо масив в множину\nlet uniqueNumbers = new Set(numbers);\n\n// Перебираємо масив та видаляємо повторювані значення\nfor (let i = 0; i < numbers.length; i++) {\n  if (uniqueNumbers.has(numbers[i])) {\n    uniqueNumbers.delete(numbers[i]);\n    console.log(numbers[i]);\n  }\n}\n\n                    ",
            "type": "Set()"
          },
          {
            "name": ".delete(item)",
            "class": "boolean",
            "description": "Set().delete(item) видаляє вказаний елемент item з множини (Set) в JavaScript.",
            "code": "//Приклад 1: Видалення елемента з множини\n \n // створення множини\nconst items = new Set([1, 2, 3, 4, 5]);\n \n// виведення розміру множини\nconsole.log(`Розмір множини до видалення: ${items.size}`); // Розмір множини до видалення: 5\n \n // видалення елемента з множини\nitems.delete(3);\n\n// виведення розміру множини після видалення\nconsole.log(`Розмір множини після видалення: ${items.size}`); // Розмір множини після видалення: 4 ",
            "type": "Set()"
          },
          {
            "name": ".clear()",
            "class": "undefined",
            "description": "Set.clear() - це метод JavaScript, який використовується для видалення всіх елементів з Set().",
            "code": "//Використання:\nconst mySet = new Set([1, 2, 3, 4]);\nconsole.log(mySet); // Set { 1, 2, 3, 4 }\nmySet.clear();\nconsole.log(mySet); // Set {}\n\n//Приклад 1: Видалення всіх елементів зі зберігання типу Set:\nconst mySet = new Set([1, 2, 3, 4, 5]);\nconsole.log(mySet); // Set { 1, 2, 3, 4, 5 }\nmySet.clear();\nconsole.log(mySet); // Set {}\n\n//Приклад 2: Видалення всіх унікальних елементів масиву:\nconst myArray = [1, 2, 3, 4, 5, 2, 3];\nconst uniqueSet = new Set(myArray);\nconsole.log(uniqueSet); // Set { 1, 2, 3, 4, 5 }\nuniqueSet.clear();\nconsole.log(uniqueSet); // Set {}",
            "type": "Set()"
          }
        ],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "Event()",
      "properties": [
        {
          "name": ".bubbles",
          "class": "boolean",
          "notice": "",
          "description": "Event.bubbles - це властивість об'єкта Event, яка вказує, чи має подія можливість здійснити \"всплиття\" (bubbling) до батьківських елементів.\n\n      Якщо значення bubbles дорівнює true, то подія може \"вспливати\" до батьківських елементів, якщо ж воно дорівнює false, то подія не буде \"вспливати\" і оброблюватиметься тільки на елементі, на якому вона виникла.",
          "code": "\n// Приклад використання:\n// Створюємо нову подію 'click' з прапорцем bubbles: true\nconst event = new Event('click', { bubbles: true });\n\n// Додаємо обробник події на дочірній елемент \nconst child = document.getElementById('child');\nchild.addEventListener('click', () => {\n  console.log('Обробник події на дочірньому елементі');\n});\n\n// Додаємо обробник події на батьківський елемент \nconst parent = document.getElementById('parent');\nparent.addEventListener('click', () => {\n  console.log('Обробник події на батьківському елементі');\n});\n\n// Запускаємо подію на дочірньому елементі \nchild.dispatchEvent(event);\n\n\n// У цьому прикладі ми створюємо нову подію 'click' з прапорцем bubbles: true.\n//  Далі додаємо обробник події на дочірній елемент з ідентифікатором child та \n// обробник події на батьківський елемент з ідентифікатором parent. При запуску \n// події на дочірньому елементі (child.dispatchEvent(event)), подія \"вспливає\" \n// до батьківського елементу і викликає обидва обробники події.\n\n\n// Інший приклад:\n// Створюємо нову подію 'click' з прапорцем bubbles: false\nconst event = new Event('click', { bubbles: false });\n\n// Додаємо обробник події на дочірній елемент \nconst child = document.getElementById('child');\nchild.addEventListener('click', () => {\n  console.log('Обробник події на дочірньому елементі');\n});\n\n// Додаємо обробник події на батьківський елемент \nconst parent = document.getElementById('parent');\nparent.addEventListener('click', () => {\n \n\n",
          "type": "Event()"
        },
        {
          "name": ".cancelable",
          "class": "boolean",
          "notice": "",
          "description": "В JavaScript, Event.cancelable - це властивість, яке вказує, чи може бути скасована подія за допомогою методу Event.preventDefault(). Значення цієї властивості - булеве true або false.\n\n      Наприклад, якщо ми маємо подію click на елементі і хочемо заборонити перехід по посиланню, можна використовувати метод Event.preventDefault(), але тільки якщо подія click є скасовуваною. Тому ми можемо перевірити, чи є подія click скасовуваною, використовуючи властивість Event.cancelable.",
          "code": "\n// Ось декілька прикладів використання:\n\n// Приклад 1: Перевірка можливості скасування події\n// Створення нової події 'myEvent'\nconst myEvent = new Event('myEvent', {\n  bubbles: true,\n  cancelable: true\n});\n\n// Перевірка можливості скасування події 'myEvent'\nconsole.log(myEvent.cancelable); // true\n\n\n// Приклад 2: Використання Event.preventDefault() для скасування події\n// Створення нового посилання\nconst link = document.createElement('a');\nlink.href = 'https://www.example.com';\n\n// Додавання обробника події 'click'\nlink.addEventListener('click', (event) => {\n  // Перевірка можливості скасування події\n  if (event.cancelable) {\n    // Скасування події\n    event.preventDefault();\n  }\n});\n\n// Додавання посилання до сторінки\ndocument.body.appendChild(link);\n\n",
          "type": "Event()"
        },
        {
          "name": ".currentTarget",
          "class": "object",
          "notice": "",
          "description": "Event.currentTarget - це властивість об'єкта події Event, яка повертає посилання на об'єкт, який був на поточний момент ціллю події. В інших словах, це елемент, на якому було встановлено обробник події, і який здійснює оброблення цієї події в поточний момент.\n\n      Наприклад, якщо ми маємо HTML-елемент з ідентифікатором myDiv, і ми встановлюємо обробник події click на цей елемент, то об'єкт, повернутий currentTarget в обробнику події click, буде посилатися на цей HTML-елемент.",
          "code": "\n// Ось два приклади використання:\n\nПриклад 1:\nconst button = document.querySelector('#myButton');\n\nbutton.addEventListener('click', function(event) {\n  console.log(`Обробник події: ${event.currentTarget}`);\n});\n\n\n// У цьому прикладі ми встановлюємо обробник події click на кнопку з ідентифікатором myButton. \n// При кожному кліку на кнопку відбувається виклик функції-обробника, \n// яка виводить в консоль посилання на об'єкт, який є поточним елементом, на якому встановлено обробник події.\n\n// Приклад 2:\nconst elements = document.querySelectorAll('.myClass');\n\nelements.forEach(function(element) {\n  element.addEventListener('click', function(event) {\n    console.log(`Натиснуто: ${event.currentTarget.textContent}`);\n  });\n});\n// У цьому прикладі ми використовуємо метод querySelectorAll() для вибору всіх HTML-елементів з класом .myClass. \n// Далі, для кожного елемента ми встановлюємо обробник події click, який виводить текстовий вміст елемента, на якому відбувся клік. \n// У цьому випадку, об'єкт, повернутий currentTarget, буде посилатися на HTML-елемент,\n//  на якому встановлено обробник події (а не на поточний елемент, на якому відбувся клік).\n      ",
          "type": "Event()"
        },
        {
          "name": ".defaultPrevented",
          "class": "boolean",
          "notice": "",
          "description": "Властивість defaultPrevented об'єкта Event вказує, чи були скасовані дії за замовчуванням у результаті виконання обробника подій. Ця властивість доступна тільки для читання і повертає булеве значення true, якщо дії за замовчуванням були скасовані інакше false.",
          "code": "\n// Ось приклад використання defaultPrevented:\nconst link = document.querySelector('a');\n\nlink.addEventListener('click', function(event) {\n  event.preventDefault();\n  console.log('Дії за замовчуванням скасовані:', event.defaultPrevented);\n});\n\n// У цьому прикладі при кліку на посилання буде скачована дія за замовчуванням (перехід на нову сторінку), \n// і в консоль буде виведено повідомлення \"Дії за замовчуванням скасовані: true\". \n// Якщо було б дозволено перехід на нову сторінку, то властивість defaultPrevented повернула б значення false.\n\n// Ось ще один приклад використання defaultPrevented:\nconst button = document.querySelector('button');\n\nbutton.addEventListener('click', function(event) {\n  if (event.defaultPrevented) {\n    console.log('Дію за замовчуванням було скасовано');\n  } else {\n    console.log('Дію за замовчуванням не було скачовано');\n  }\n});\n\nbutton.click(); // Викликати подію click\n\n// У цьому прикладі ми перевіряємо, чи були скасовані дії за замовчуванням при кліку на кнопку.\n//  Ви могли помітити, що ми викликаємо подію click на кнопці безпосередньо після додавання обробника подій, \n// тому що у нас немає іншого способу, який дозволяє попередньо скачувати дії за замовчуванням при кліку на кнопку.\n//  У цьому прикладі в консоль буде виведено повідомлення \"Дію за замовчуванням не було скачовано\".\n",
          "type": "Event()"
        },
        {
          "name": ".detail",
          "class": "number",
          "notice": "",
          "description": "В JavaScript події (Events) можуть містити корисну інформацію для обробників подій, таку як дані, що відносяться до того, що сталося, і які дії можна виконати після події. Властивість detail об'єкту події містить цю інформацію.\n\n      Наприклад, якщо ви генеруєте подію \"click\" на елементі списку, event.detail може містити деталі про те, який елемент був клікнутий в списку. Таким чином, ви можете використовувати цю інформацію для визначення, який елемент потрібно вибрати у списку.",
          "code": "\n// Ось два приклади використання event.detail:\n\n// Приклад 1:\nconst list = document.querySelector('#list');\nlist.addEventListener('click', (event) => {\n  const clickedItem = event.detail.item;\n  console.log(`Ви клікнули на елементі: ${clickedItem}`);\n});\n\n// У цьому прикладі ми додаємо обробник подій до списку з ID list. \n// Коли користувач клікає на елемент списку, \n// обробник подій викликається і виводиться повідомлення з інформацією про те, який елемент був клікнутий.\n\n// Приклад 2:\nconst button = document.querySelector('#button');\nbutton.addEventListener('custom-event', (event) => {\n  const eventData = event.detail;\n  console.log(`Деталі події: ${eventData}`);\n});\n\n// У цьому прикладі ми додаємо обробник подій до кнопки з ID button.\n//  Коли ми генеруємо настоману подію custom-event на кнопці, \n// обробник подій викликається і виводиться повідомлення з деталями про цю подію, які містяться в event.detail.\n      ",
          "type": "Event()"
        },
        {
          "name": ".eventPhase",
          "class": "number",
          "notice": "",
          "description": "Event().eventPhase - це властивість, що повертає ціле число, яке вказує на фазу події, на якій було спричинено подію. Значення цієї властивості може бути одним з чотирьох цілих чисел, що відповідають за такі фази подій:\n\n      Event.NONE (0): це значення означає, що подія ще не була ініційована.\n      Event.CAPTURING_PHASE (1): фаза захоплення, коли подія знаходиться на шляху до досягнення цільового елемента.\n      Event.AT_TARGET (2): фаза досягнення цільового елемента.\n      Event.BUBBLING_PHASE (3): фаза збору, коли подія переміщується назад до кореневого елемента.",
          "code": "\n// Нижче подані два приклади використання eventPhase:\n\n// Приклад 1:\nconst button = document.querySelector('button');\n\nbutton.addEventListener('click', function(event) {\n  console.log(`Фаза події: ${event.eventPhase}`);\n}, true);\n\n// У цьому прикладі ми додаємо прослуховувач подій для кнопки, що включає захоплення (параметр true у третьому аргументі addEventListener). \n// Після того, як кнопка буде натиснута, у консоль буде виведено Фаза події: 1, означаючи, що подія знаходиться на фазі захоплення.\n\n// Приклад 2:\nconst div = document.querySelector('div');\n\ndiv.addEventListener('click', function(event) {\n  console.log(`Фаза події: ${event.eventPhase}`);\n}, false);\n\ndocument.addEventListener('click', function(event) {\n  console.log(`Фаза події: ${event.eventPhase}`);\n}, true);\n\n//У цьому прикладі ми додаємо прослуховувачи подій для елементу div та кореневого елемента документа. \n// Після кліку на div у консоль буде виведено Фаза події: 2, означаючи, що подія досягла цільового елемента. \n// Після кліку на будь-який інший елемент сторінки, у консоль буде виведено Фаза події: 1, означаючи, що подія знаходиться на фазі захоплення під\n",
          "type": "Event()"
        },
        {
          "name": ".isTrusted",
          "class": "boolean",
          "notice": "",
          "description": "Властивість isTrusted у події Event повертає логічне значення, яке показує, чи є подія справжньою, тобто була викликана користувачем, чи була симульована з коду. Якщо значення isTrusted дорівнює true, то подія була ініційована користувачем, інакше вона була симульована.",
          "code": "\n// Приклад 1: Використання isTrusted для перевірки, чи була подія клік миші ініційована користувачем:\nconst button = document.querySelector('button');\nbutton.addEventListener('click', (event) => {\n  if (event.isTrusted) {\n    console.log('Клік на кнопці ініційований користувачем');\n  } else {\n    console.log('Клік на кнопці був симульований з коду');\n  }\n});\n\n// Приклад 2: Використання isTrusted для перевірки, чи подія клавіатури ініційована користувачем:\ndocument.addEventListener('keydown', (event) => {\n  if (event.isTrusted) {\n    console.log('Клавіша натиснута користувачем');\n  } else {\n    console.log('Клавіша натиснута з коду');\n  }\n});\n\n// У цьому прикладі isTrusted допомагає визначити, чи була натиснута клавіша на клавіатурі користувачем чи симульована з коду.\n",
          "type": "Event()"
        },
        {
          "name": ".target",
          "class": "object",
          "notice": "",
          "description": "Event().target - це властивість об'єкта події, яка повертає посилання на об'єкт, який викликав подію. Ця властивість зазвичай використовується для визначення елементу, на якому відбувається подія.",
          "code": "\n// Наприклад, якщо на сторінці є кнопка, і ви хочете викликати функцію, коли користувач клікає на цю кнопку, \n// ви можете додати обробник подій до кнопки і використовувати Event().target для отримання посилання на кнопку:\nconst button = document.querySelector('#myButton');\n\nbutton.addEventListener('click', function(event) {\n  console.log('Клікнуто на кнопку', event.target);\n});\n// У цьому прикладі event.target повертає посилання на кнопку, на яку було клікнуто.\n\n// Інший приклад використання Event().target - це динамічне створення обробників подій для кількох елементів на сторінці:\nconst buttons = document.querySelectorAll('.myButton');\n\nbuttons.forEach(function(button) {\n  button.addEventListener('click', function(event) {\n    console.log(`Клікнуто на кнопку з текстом: ${event.target.textContent}`);\n  });\n});\n\n// У цьому прикладі ми використовуємо querySelectorAll() для отримання всіх елементів на сторінці з класом myButton, \n// а потім додаємо обробник подій до кожної з цих кнопок.\n//  У функції обробника подій ми використовуємо event.target для отримання посилання на кнопку,\n//  на яку було клікнуто, і виводимо текст цієї кнопки.\n\n      ",
          "type": "Event()"
        },
        {
          "name": ".timeStamp ",
          "class": "number",
          "notice": "",
          "description": "Event().timeStamp - це властивість, що повертає час у мілісекундах, який пройшов від початку виконання скрипту до моменту виникнення події.",
          "code": "\n// Наприклад:\nconst button = document.querySelector('button');\nbutton.addEventListener('click', function(event) {\n  console.log(`Час від початку виконання скрипту до виникнення події: ${event.timeStamp}`);\n});\n// У цьому прикладі ми прикріплюємо обробник подій на кнопку, щоб слідкувати за подією кліку. \n// При виникненні події об'єкт події передається як аргумент в обробник,\n//  і ми можемо використати event.timeStamp, щоб отримати час у мілісекундах, \n// який пройшов від початку виконання скрипту до виникнення події.\n\n// Інший приклад:\nconst start = Date.now();\nconst button = document.querySelector('button');\nbutton.addEventListener('click', function(event) {\n  console.log(`Час від початку виконання скрипту до виникнення події: ${event.timeStamp - start}`);\n});\n\n//У цьому прикладі ми записуємо час початку виконання скрипту в змінну start, \n// а потім використовуємо event.timeStamp для визначення часу, \n// який пройшов від початку виконання скрипту до виникнення події. \n// Віднімаючи start від event.timeStamp, ми отримуємо час в мілісекундах, \n// який пройшов між початком виконання скрипту і виникненням події. \n\n      ",
          "type": "Event()"
        },
        {
          "name": ".type",
          "class": "string",
          "notice": "",
          "description": "Об'єкт Event у JavaScript містить інформацію про певну подію, яка відбулася на елементі DOM. Властивість type представляє тип події, тобто ім'я події, що була викликана.",
          "code": "\n// Приклад використання 1:\n// Додамо обробник події кліку на кнопку з ID \"myBtn\"\nconst myBtn = document.getElementById(\"myBtn\");\nmyBtn.addEventListener(\"click\", function(event) {\n  console.log(event.type); // \"click\"\n});\n// У цьому прикладі, ми створюємо обробник події кліку на кнопку з ID \"myBtn\".\n//  Потім використовуємо властивість type для виведення назви події в консоль.\n\n// Приклад використання 2:\n// Додамо обробник події клавіатури на весь документ\ndocument.addEventListener(\"keydown\", function(event) {\n  console.log(event.type); // \"keydown\"\n});\n// У цьому прикладі, ми створюємо обробник події клавіатури на весь документ. \n// Потім використовуємо властивість type для виведення назви події в консоль.\n      ",
          "type": "Event()"
        }
      ],
      "methods": {
        "basicMethods": [
          {
            "name": ".preventDefault() ",
            "class": "undefined",
            "notice": "",
            "description": "Метод preventDefault() класу Event у JavaScript використовується для скасування дії за замовчуванням, яка пов'язана з подією, що спричинила цей обробник подій. Наприклад, якщо обробник подій призначений для кнопки, яка зазвичай спричиняє перехід на нову сторінку, метод preventDefault() може запобігти переходу на нову сторінку.",
            "code": "\n// Ось два приклади використання методу preventDefault():\n\n// Приклад 1: Запобігання переходу на нову сторінку при кліку на посилання\nconst link = document.querySelector('a');\n\nlink.addEventListener('click', (event) => {\n  event.preventDefault();\n  console.log('Клік на посиланні не приводить до переходу на нову сторінку');\n});\n// У цьому прикладі, при кліку на посилання, метод preventDefault() зупиняє перехід на нову сторінку та виводить повідомлення в консолі\n\n// Приклад 2: Запобігання відправки форми при натисканні кнопки\nconst form = document.querySelector('form');\n\nform.addEventListener('submit', (event) => {\n  event.preventDefault();\n  console.log('Відправка форми не відбулася');\n});\n// У цьому прикладі, при натисканні кнопки для відправки форми, метод preventDefault() зупиняє відправку форми та виводить повідомлення в консолі.\n        ",
            "type": "Event()"
          },
          {
            "name": ".stopImmediatePropagation()",
            "class": "undefined",
            "notice": "",
            "description": "Метод stopImmediatePropagation() зупиняє поширення події і забороняє виконання інших обробників подій для того ж об'єкта події. Він не тільки зупиняє подальшу передачу події, але і зупиняє виконання інших обробників, призначених для цього ж об'єкта події.",
            "code": "\n// Приклад 1:\n// Оголошення функції-обробника подій\nfunction eventHandler(event) {\n  console.log(\"Перший обробник подій\");\n  event.stopImmediatePropagation();\n  console.log(\"Подія зупинена.\");\n}\n\n// Додавання обробника подій до об'єкта button\nlet button = document.getElementById(\"myButton\");\nbutton.addEventListener(\"click\", eventHandler);\nbutton.addEventListener(\"click\", function() {\n  console.log(\"Другий обробник подій\");\n});\n// У цьому прикладі, коли користувач клікає на кнопку, спочатку виконується функція eventHandler(),\n// яка зупиняє подальше виконання інших обробників подій. Тому другий обробник подій не виконується.\n\n// Приклад 2:\n// Оголошення функції-обробника подій\nfunction eventHandler(event) {\n  console.log(\"Перший обробник подій\");\n  event.stopImmediatePropagation();\n  console.log(\"Подія зупинена.\");\n}\n\n// Додавання обробника подій до об'єкта button\nlet button = document.getElementById(\"myButton\");\nbutton.addEventListener(\"click\", eventHandler);\nbutton.addEventListener(\"click\", function() {\n  console.log(\"Другий обробник подій\");\n});\nbutton.addEventListener(\"click\", function() {\n  console.log(\"Третій обробник подій\");\n});\n// У цьому прикладі, коли користувач клікає на кнопку, спочатку виконується функція eventHandler(), \n// яка зупиняє подальше виконання інших обробників подій. Тому другий та третій обробники подій не виконуються.\n",
            "type": "Event()"
          },
          {
            "name": ".stopPropagation()",
            "class": "undefined",
            "notice": "",
            "description": "Event.stopPropagation() - це метод, що зупиняє подальше розповсюдження події, запобігаючи виклику обробника подій для батьківських елементів. Цей метод виконується на об'єкті події і може бути викликаний в обробнику подій, щоб заборонити подальше поширення події.",
            "code": "\n// Ось два приклади використання:\n\n// Приклад 1:\n// Створення обробника подій на кнопці\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function(event) {\n  event.stopPropagation(); // зупинити подальше розповсюдження події\n  // робимо щось\n});\n// У цьому прикладі, якщо користувач клікне на кнопці з id=\"myButton\", \n// то обробник подій зупинить подальше розповсюдження події, \n// запобігаючи виклику обробника подій для батьківських елементів.\n\n// Приклад 2:\n// Створення обробника подій на батьківському елементі\ndocument.getElementById(\"myDiv\").addEventListener(\"click\", function(event) {\n  // робимо щось\n});\n\n// Створення обробника подій на дочірньому елементі\ndocument.getElementById(\"myButton\").addEventListener(\"click\", function(event) {\n  event.stopPropagation(); // зупинити подальше розповсюдження події\n  // робимо щось\n});\n// У цьому прикладі, якщо користувач клікне на кнопці з id=\"myButton\", то обробник подій на дочірньому елементі буде викликано, \n// але обробник подій на батьківському елементі не буде викликано, оскільки event.stopPropagation() зупинить подальше розповсюдження події.\n",
            "type": "Event()"
          }
        ],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "ChildNode()",
      "properties": [

      ],
      "methods": {
        "basicMethods": [        {
          "name": ".remove() ",
          "class": "object",
          "notice": "",
          "description": "ChildNode.remove() - метод, який видаляє поточний вузол зі структури DOM, до якої він належить.",
          "code": "\n// Приклад 1: видалення елемента з DOM\n<div id=\"myDiv\">Вміст</div>\n\nconst myDiv = document.querySelector('#myDiv');\nmyDiv.remove();\n\n// У цьому прикладі метод remove() видаляє елемент з id \"myDiv\" зі структури DOM.\n\n\n// Приклад 2: видалення текстового вузла зі структури DOM\n<div id=\"myDiv\">Вміст текстового вузла</div>\n\nconst myDiv = document.querySelector('#myDiv');\nconst textNode = myDiv.childNodes[0];\ntextNode.remove();\n// У цьому прикладі метод remove() видаляє текстовий вузол зі структури DOM, який знаходиться в елементі з id \"myDiv\".\n",
          "type": "ChildNode()"
        }],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "ParentNode()",
      "properties": [
        {
          "name": ".childElementCount",
          "class": "number",
          "notice": "",
          "description": "Метод childElementCount властивості ParentNode повертає кількість дочірніх елементів-вузлів вузла, які є елементами.",
          "code": "\n// Приклад 1: Визначення кількості дочірніх елементів-вузлів елемента div\nconst divElement = document.querySelector('div');\nconst childCount = divElement.childElementCount;\nconsole.log(`Кількість дочірніх елементів-вузлів елемента div: ${childCount}`);\n// У цьому прикладі ми використовуємо querySelector для знаходження першого елемента div на сторінці, \n// а потім використовуємо childElementCount, щоб визначити кількість його дочірніх елементів-вузлів.\n\n// Приклад 2: Перевірка, чи має елемент дочірні елементи\nconst ulElement = document.querySelector('ul');\nif (ulElement.childElementCount > 0) {\n  console.log('Елемент має дочірні елементи');\n} else {\n  console.log('Елемент не має дочірніх елементів');\n}\n//У цьому прикладі ми перевіряємо, чи має список ul дочірні елементи. \n// Якщо childElementCount більше нуля, тоді ми виводимо повідомлення, що елемент має дочірні елементи. \n// В іншому випадку, ми виводимо повідомлення, що елемент не має дочірніх елементів. \n",
          "type": "ParentNode()"
        },
        {
          "name": ".children",
          "class": "object",
          "notice": "",
          "description": "Метод children властивості ParentNode у JavaScript повертає колекцію дочірніх елементів вказаного елементу в вигляді об'єкта HTMLCollection.",
          "code": "\n// Ось приклад використання методу children:\nconst parent = document.getElementById('parent');\nconst children = parent.children;\n\nfor(let i = 0; i < children.length; i++) {\n  console.log(children[i].tagName);\n}\n// У цьому прикладі ми отримуємо елемент з ідентифікатором parent, а потім знаходимо його дочірні елементи з допомогою методу children.\n// Потім ми проходимося по цьому списку дочірніх елементів і виводимо назву тегу кожного елементу у консоль.\n\n// Ось ще один приклад використання методу children:\nconst parent = document.getElementById('parent');\nconst children = parent.children;\n\nfor(let i = 0; i < children.length; i++) {\n  children[i].style.color = 'red';\n}\n// У цьому прикладі ми знову отримуємо елемент з ідентифікатором parent і його дочірні елементи. \n// Потім ми проходимося по кожному дочірньому елементу та змінюємо його колір на червоний.\n\n// Отже, метод children може бути корисним, коли нам потрібно працювати з дочірніми елементами батьківського елемента.\n",
          "type": "ParentNode()"
        },
        {
          "name": ".firstElementChild",
          "class": "object",
          "notice": "",
          "description": "Метод firstElementChild у JavaScript є властивістю об'єкта ParentNode. Він повертає перший елемент-нащадок батьківського елемента. Цей метод особливо корисний, коли ви хочете отримати доступ до першого дочірнього елемента, який є елементом-тегом, тобто першого елемента-нащадка. Він також корисний, коли ви хочете швидко змінити властивості першого елемента-нащадка.",
          "code": "\n// Приклад 1:\nconst parent = document.querySelector('.parent');\nconst firstChild = parent.firstElementChild;\nconsole.log(firstChild);\n//У цьому прикладі ми використовуємо firstElementChild для отримання першого елемента-нащадка елемента з класом \"parent\". \n//Змінна firstChild буде містити перший елемент-нащадок, а метод console.log() виведе цей елемент у консоль.\n\n// Приклад 2:\nconst parent = document.querySelector('.parent');\nparent.firstElementChild.style.color = 'red';\n// У цьому прикладі ми використовуємо firstElementChild, щоб змінити колір тексту першого елемента-нащадка елемента з класом \"parent\". \n// Ми просто встановлюємо стиль color на червоний для елемента-нащадка, який повертається методом firstElementChild.\n\n// \n",
          "type": "ParentNode()"
        },
        {
          "name": ".lastElementChild",
          "class": "object",
          "notice": "",
          "description": "Метод lastElementChild об'єкту ParentNode повертає останній елемент-нащадок вказаного батьківського елемента, якщо такий елемент існує, або null в іншому випадку. Загалом, метод lastElementChild корисний тоді, коли вам потрібно отримати посилання на останній елемент в розташуванні за порядком відносно батьківського елемента.",
          "code": "\n// Приклад 1: Знаходження останнього елемента списку\n<ul id=\"myList\">\n  <li>Перший елемент</li>\n  <li>Другий елемент</li>\n  <li>Третій елемент</li>\n</ul>\n\n<script>\n  const myList = document.getElementById(\"myList\");\n  const lastElement = myList.lastElementChild;\n  console.log(lastElement.textContent); // виведе \"Третій елемент\"\n</script>\n// У цьому прикладі ми спочатку отримуємо посилання на елемент списку з його ID.\n// Потім ми використовуємо метод lastElementChild, щоб отримати останній елемент у списку, і виводимо його текстовий вміст у консолі.\n\n// Приклад 2: Використання в обробнику подій\n<div id=\"myDiv\">\n  <p>Перший абзац</p>\n  <p>Другий абзац</p>\n  <p>Третій абзац</p>\n</div>\n\n<script>\n  const myDiv = document.getElementById(\"myDiv\");\n  myDiv.addEventListener(\"click\", function() {\n    const lastParagraph = this.lastElementChild;\n    lastParagraph.style.color = \"red\";\n  });\n</script>\n// У цьому прикладі ми додаємо обробник подій click до елемента myDiv. \n// Коли користувач клікає на myDiv, ми використовуємо метод lastElementChild, щоб отримати останній абзац у myDiv, і змінюємо його колір на червоний.\n",
          "type": "ParentNode()"
        }
      ],
      "methods": {
        "basicMethods": [],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    },
    {
      "titleBlock": "NonDocumentTypeChildNode()",
      "properties": [
        {
          "name": ".nextElementSibling",
          "class": "object",
          "notice": "",
          "description": "Властивість nextElementSibling повертає елемент, що йде наступним за поточним елементом в дереві DOM на одному рівні. Це означає, що елементи, які перебувають в батьківському вузлі, взаємодіють між собою через цю властивість.\n\n      Наприклад, якщо є список елементів, які перебувають на одному рівні в дереві DOM, і ви хочете отримати наступний елемент, ви можете використовувати властивість nextElementSibling. Якщо наступного елемента немає, то повернеться null.",
          "code": "\n// Приклад 1:\n<ul>\n  <li>Пункт 1</li>\n  <li id=\"current\">Пункт 2</li>\n  <li>Пункт 3</li>\n  <li>Пункт 4</li>\n</ul>\n\n<script>\n  const current = document.getElementById(\"current\");\n  const next = current.nextElementSibling;\n  console.log(next.textContent); // Виведе \"Пункт 3\"\n</script>\n// У цьому прикладі ми шукаємо елемент з ідентифікатором \"current\" і отримуємо наступний елемент в списку, \n// використовуючи властивість nextElementSibling. Результат виводиться в консоль.\n\n// Приклад 2:\n<div>\n  <p>Перший абзац</p>\n  <span>Перший спан</span>\n  <p>Другий абзац</p>\n  <span>Другий спан</span>\n  <p>Третій абзац</p>\n</div>\n\n<script>\n  const firstSpan = document.querySelector(\"span:first-of-type\");\n  const next = firstSpan.nextElementSibling;\n  console.log(next.tagName); // Виведе \"P\"\n</script>\n// У цьому прикладі ми шукаємо перший елемент \"span\" і отримуємо наступний елемент, використовуючи властивість nextElementSibling. \n// Цього разу ми отримали наступний елемент-абзац. Результат виводиться в консоль.\n",
          "type": "NonDocumentTypeChildNode()"
        },
        {
          "name": ".previousElementSibling",
          "class": "object",
          "notice": "",
          "description": "Метод previousElementSibling повертає попередній DOM-елемент на тому самому рівні вкладеності.",
          "code": "\n// Наприклад, уявімо, що у нас є наступна HTML-розмітка:\n<div id=\"container\">\n  <p>Перший абзац</p>\n  <p>Другий абзац</p>\n  <p>Третій абзац</p>\n</div>\n\n// Ми можемо використати метод previousElementSibling на третьому абзаці, щоб отримати посилання на другий абзац:\nconst thirdParagraph = document.querySelector('#container p:nth-child(3)');\nconst secondParagraph = thirdParagraph.previousElementSibling;\nconsole.log(secondParagraph.textContent); // \"Другий абзац\"\n// У цьому прикладі ми використовуємо селектор CSS :nth-child, щоб вибрати третій абзац.\n// Потім ми використовуємо метод previousElementSibling на цьому елементі, щоб отримати посилання на другий абзац.\n\n\n// Інший приклад використання - переходження по елементах з використанням циклу:\nconst items = document.querySelectorAll('.item');\nfor (let i = 1; i < items.length; i++) {\n  const previousItem = items[i].previousElementSibling;\n  console.log(previousItem.textContent);\n}\n\nconst items = document.querySelectorAll('.item');\nfor (let i = 1; i < items.length; i++) {\n  const previousItem = items[i].previousElementSibling;\n  console.log(previousItem.textContent);\n}\n\n// У цьому прикладі ми використовуємо метод previousElementSibling для переходу від елементу до елементу за допомогою циклу for. \n// Ми отримуємо текстовий контент попереднього елементу та виводимо його в консоль.\n",
          "type": "NonDocumentTypeChildNode()"
        }
      ],
      "methods": {
        "basicMethods": [],
        "data1": { "data1title": "", "data2": [] },
        "data2": { "data1title": "", "data3": [] },
        "data3": { "data1title": "", "data4": [] },
        "data4": { "data1title": "", "data5": [] }
      }
    }
    
    
  ]
  